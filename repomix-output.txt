This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
src/.idea/misc.xml
src/.idea/vcs.xml
src/.idea/workspace.xml
src/main/java/console/Command.java
src/main/java/console/CommandCompleter.java
src/main/java/console/Commands.java
src/main/java/console/ConsoleGUI.java
src/main/java/console/ConsoleHandler.java
src/main/java/console/ScriptModeDocument.java
src/main/java/control/KeyHandler.java
src/main/java/control/MouseHandler.java
src/main/java/GameController.java
src/main/java/GameFileChooser.java
src/main/java/GameMenu.java
src/main/java/GameOverVisitor.java
src/main/java/GamePanel.java
src/main/java/GameState.java
src/main/java/Geometry.java
src/main/java/insect/AddInsectVisitor.java
src/main/java/insect/Insect.java
src/main/java/insect/RemoveInsectVisitor.java
src/main/java/Main.java
src/main/java/MainMenu.java
src/main/java/mushroom/CanGrowBodyVisitor.java
src/main/java/mushroom/CanKillStringVisitor.java
src/main/java/mushroom/GeometryString.java
src/main/java/mushroom/KeepStringAliveVisitor.java
src/main/java/mushroom/Mushroom.java
src/main/java/mushroom/MushroomBody.java
src/main/java/mushroom/MushroomString.java
src/main/java/Nameable.java
src/main/java/Planet.java
src/main/java/player/Insecter.java
src/main/java/player/Player.java
src/main/java/player/PlayerAccept.java
src/main/java/player/PlayerVisitor.java
src/main/java/player/Shroomer.java
src/main/java/spore/FastSpore.java
src/main/java/spore/GentleSpore.java
src/main/java/spore/MultiplierSpore.java
src/main/java/spore/ParalyzerSpore.java
src/main/java/spore/SlowSpore.java
src/main/java/spore/Spore.java
src/main/java/spore/SporeAccept.java
src/main/java/spore/SporeConsumptionVisitor.java
src/main/java/spore/SporeVisitor.java
src/main/java/tecton/BigTecton.java
src/main/java/tecton/CoarseTecton.java
src/main/java/tecton/GeometryTecton.java
src/main/java/tecton/HealingTecton.java
src/main/java/tecton/SmallTecton.java
src/main/java/tecton/Tecton.java
src/main/java/tecton/TectonAccept.java
src/main/java/tecton/TectonDrawerVisitor.java
src/main/java/tecton/TectonVisitor.java
src/main/java/tecton/ToxicTecton.java
src/main/java/Updatable.java
src/main/java/view/DefaultDrawingFactory.java
src/main/java/view/DefaultInsectDrawer.java
src/main/java/view/DefaultMushroomBodyDrawer.java
src/main/java/view/DefaultMushroomStringDrawer.java
src/main/java/view/DefaultSporeDrawer.java
src/main/java/view/DefaultTectonDrawer.java
src/main/java/view/Drawable.java
src/main/java/view/DrawingFactory.java
src/main/java/view/DrawManager.java
src/main/java/view/InsectDrawer.java
src/main/java/view/MushroomBodyDrawer.java
src/main/java/view/MushroomStringDrawer.java
src/main/java/view/SporeDrawer.java
src/main/java/view/TectonDrawer.java
src/main/java/view/UtilityTool.java
src/scripts/file1.txt
src/scripts/script1.txt
src/szoftprojlab.iml
src/test/java/Tesztek/test10/expected.txt
src/test/java/Tesztek/test10/input.txt
src/test/java/Tesztek/test11/expected.txt
src/test/java/Tesztek/test11/input.txt
src/test/java/Tesztek/test12/expected.txt
src/test/java/Tesztek/test12/input.txt
src/test/java/Tesztek/test13/expected.txt
src/test/java/Tesztek/test13/input.txt
src/test/java/Tesztek/test14/expected.txt
src/test/java/Tesztek/test14/input.txt
src/test/java/Tesztek/test15/expected.txt
src/test/java/Tesztek/test15/input.txt
src/test/java/Tesztek/test16/expected.txt
src/test/java/Tesztek/test16/input.txt
src/test/java/Tesztek/test17/expected.txt
src/test/java/Tesztek/test17/input.txt
src/test/java/Tesztek/test18/expected.txt
src/test/java/Tesztek/test18/input.txt
src/test/java/Tesztek/test19/expected.txt
src/test/java/Tesztek/test19/input.txt
src/test/java/Tesztek/test2/expected.txt
src/test/java/Tesztek/test2/input.txt
src/test/java/Tesztek/test20/expected.txt
src/test/java/Tesztek/test20/input.txt
src/test/java/Tesztek/test21/expected.txt
src/test/java/Tesztek/test21/input.txt
src/test/java/Tesztek/test22/expected.txt
src/test/java/Tesztek/test22/input.txt
src/test/java/Tesztek/test23/expected.txt
src/test/java/Tesztek/test23/input.txt
src/test/java/Tesztek/test24/expected.txt
src/test/java/Tesztek/test24/input.txt
src/test/java/Tesztek/test25/expected.txt
src/test/java/Tesztek/test25/input.txt
src/test/java/Tesztek/test26/expected.txt
src/test/java/Tesztek/test26/input.txt
src/test/java/Tesztek/test27/expected.txt
src/test/java/Tesztek/test27/input.txt
src/test/java/Tesztek/test28/expected.txt
src/test/java/Tesztek/test28/input.txt
src/test/java/Tesztek/test29/expected.txt
src/test/java/Tesztek/test29/input.txt
src/test/java/Tesztek/test3/expected.txt
src/test/java/Tesztek/test3/input.txt
src/test/java/Tesztek/test30/expected.txt
src/test/java/Tesztek/test30/input.txt
src/test/java/Tesztek/test31/expected.txt
src/test/java/Tesztek/test31/input.txt
src/test/java/Tesztek/test4/expected.txt
src/test/java/Tesztek/test4/input.txt
src/test/java/Tesztek/test5/expected.txt
src/test/java/Tesztek/test5/input.txt
src/test/java/Tesztek/test6/expected.txt
src/test/java/Tesztek/test6/input.txt
src/test/java/Tesztek/test7/expected.txt
src/test/java/Tesztek/test7/input.txt
src/test/java/Tesztek/test8/expected.txt
src/test/java/Tesztek/test8/input.txt
src/test/java/Tesztek/test9/expected.txt
src/test/java/Tesztek/test9/input.txt
szoftprojlab.iml
szoftprojlabGrafikus.iml

================================================================
Files
================================================================

================
File: .gitignore
================
/bin/

================
File: src/.idea/workspace.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="9c8e4104-15a1-47de-8519-dc8181308d28" name="Changes" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProblemsViewState">
    <option name="selectedTabId" value="CurrentFile" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 4
}</component>
  <component name="ProjectId" id="2wp6R30N41KU6RuuYIidFkyWQS4" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;Application.GamePanel.executor&quot;: &quot;Run&quot;,
    &quot;Application.Main.executor&quot;: &quot;Run&quot;,
    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,
    &quot;ModuleVcsDetector.initialDetectionPerformed&quot;: &quot;true&quot;,
    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,
    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,
    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
    &quot;last_opened_file_path&quot;: &quot;C:/Users/Nagy/Desktop/Projlab/new/szoftprojlab/src&quot;,
    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
  }
}</component>
  <component name="RunManager">
    <configuration default="true" type="JetRunConfigurationType">
      <module name="szoftprojlab" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration default="true" type="KotlinStandaloneScriptRunConfigurationType">
      <module name="szoftprojlab" />
      <option name="filePath" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-jdk-9823dce3aa75-fbdcb00ec9e3-intellij.indexing.shared.core-IU-251.25410.129" />
        <option value="bundled-js-predefined-d6986cc7102b-6a121458b545-JavaScript-IU-251.25410.129" />
      </set>
    </attachedChunks>
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="9c8e4104-15a1-47de-8519-dc8181308d28" name="Changes" comment="" />
      <created>1746726157990</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1746726157990</updated>
      <workItem from="1746726161161" duration="8187000" />
      <workItem from="1746814684871" duration="16135000" />
      <workItem from="1746893011423" duration="101000" />
      <workItem from="1746893177052" duration="111000" />
      <workItem from="1746893355151" duration="78000" />
      <workItem from="1746893806177" duration="31000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
</project>

================
File: src/main/java/console/Command.java
================
package main.java.console;

/**
 * A parancs interfész, amely definiálja a konzol parancsok közös struktúráját.
 */

public interface Command {
    void execute(String[] args);
}

================
File: src/main/java/console/CommandCompleter.java
================
package main.java.console;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class CommandCompleter {
    
    private String lastCompletion = null;
    private final List<String> currentCompletions = new ArrayList<>(getScriptFiles());
    private List<String> scriptFiles = new ArrayList<>();
    private int currentIndex = -1;

    private final List<String> commands = Arrays.asList(
            "help", "reset", "exit", "exit_game", "remove", "save",
            "load", "set", "get", "add", "teleport", "script", "make");

    private final Map<String, List<String>> subCommands = Map.of(
            "set", Arrays.asList("player", "entity", "speed", "health", "maxhealth"),
            "get", Arrays.asList("player", "health", "speed", "maxhealth"),
            "add", Arrays.asList("boots", "chest", "door", "dragonenemy", "friendlyenemy",
                    "giantenemy", "key", "smallenemy", "sword"),
            "remove", Arrays.asList("all", "dragonenemy", "friendlyenemy", "giantenemy", "smallenemy"),
            "help", Arrays.asList("reset", "remove", "save", "load", "set", "get", "add", "teleport",
                    "script", "make"));

    /**
     * Kiegészíti a megadott bemenetet a következő lehetséges paranccsal.
     * @param input a felhasználó által beírt szöveg
     * @param isNextCompletion jelzi, hogy ez egy következő kiegészítési kísérlet-e
     * @return a kiegészített parancs
     */
    public String complete(String input, boolean isNextCompletion) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        String[] parts = input.trim().split("\\s+");
        boolean hasSpaceAtTheEnd = input.endsWith(" ");
        if (parts.length == 1 && !hasSpaceAtTheEnd) {
            return completeMainCommand(parts[0], isNextCompletion);
        }
        else {
            String mainCommand = parts[0].toLowerCase();
            String partial = hasSpaceAtTheEnd ? "" : parts[parts.length - 1].toLowerCase();

            if ("script".equals(mainCommand)) {
                if (!hasSpaceAtTheEnd) {
                    currentCompletions.clear();
                    currentIndex = -1;
                    lastCompletion = partial;

                    if ("script".startsWith(partial)) {
                        currentCompletions.add("script");
                    }
                } else {
                    currentCompletions.clear();
                    currentIndex = -1;
                    lastCompletion = partial;
                    scriptFiles = getScriptFiles();
                    if (currentCompletions.isEmpty()) {
                        currentCompletions.addAll(scriptFiles);
                    }
                }
            } else {
                if (!isNextCompletion || !Objects.equals(lastCompletion, partial)) {
                    initializeCompletions(mainCommand, partial, hasSpaceAtTheEnd);
                }
            }
            if (currentIndex >= currentCompletions.size() - 1) {
                currentIndex = -1;
            }
            if (!currentCompletions.isEmpty()) {
                currentIndex++;
                lastCompletion = currentCompletions.get(currentIndex);
                return String.join(" ", Arrays.copyOf(parts, parts.length - (hasSpaceAtTheEnd ? 0 : 1))) + (hasSpaceAtTheEnd ? "" : " ") + lastCompletion;
            }
            return input;
        }
    }


    private String completeMainCommand(String partial, boolean isNextCompletion) {
        if (!isNextCompletion || !Objects.equals(lastCompletion, partial)) {
            initializeMainCompletions(partial);
        }
        if (currentIndex >= currentCompletions.size() - 1) {
            currentIndex = -1;
        }

        if (!currentCompletions.isEmpty()) {
            currentIndex++;
            lastCompletion = currentCompletions.get(currentIndex);
            return lastCompletion;
        }
        return partial;
    }

    private void initializeCompletions(String mainCommand, String partial, boolean hasTrailingSpace) {
        currentCompletions.clear();
        currentIndex = -1;
        lastCompletion = partial;

        if (subCommands.containsKey(mainCommand)) {
            List<String> subs = subCommands.get(mainCommand);

            if (!hasTrailingSpace && !partial.isEmpty()) {
                subs.stream()
                        .filter(sub -> sub.startsWith(partial))
                        .sorted().forEach(currentCompletions::add);
            }
            subs.stream()
                    .filter(sub -> !currentCompletions.contains(sub))
                    .sorted().forEach(currentCompletions::add);
        }
    }

    public List<String> getScriptFiles() {
        List<String> scriptFiles = new ArrayList<>();
        File scriptDir = new File("res/scripts");
        if (scriptDir.exists() && scriptDir.isDirectory()) {
            File[] files = scriptDir.listFiles((dir, name) -> name.endsWith(".txt"));
            if (files != null) {
                for (File file : files) {
                    scriptFiles.add(file.getName().replace(".txt", ""));
                }
                Collections.sort(scriptFiles);
            }
        }
        return scriptFiles;
    }


    private void initializeMainCompletions(String partial) {
        currentCompletions.clear();
        currentIndex = -1;
        lastCompletion = partial;

        if (!partial.isEmpty()) {
            commands.stream()
                    .filter(cmd -> cmd.startsWith(partial))
                    .sorted().forEach(currentCompletions::add);
        }

        commands.stream()
                .filter(cmd -> !currentCompletions.contains(cmd))
                .sorted().forEach(currentCompletions::add);
    }
}

================
File: src/main/java/insect/AddInsectVisitor.java
================
package main.java.insect;

import main.java.player.*;

public class AddInsectVisitor implements PlayerVisitor
{
    private final Insect insect;
    private final Insect clone;

    public AddInsectVisitor(Insect insect, Insect clone) {
        this.insect = insect;
        this.clone = clone;
    }

    public void visit(Insecter insecter)
    {
        if (insecter.getInsects().contains(insect)) {
            insecter.getInsects().add(clone);
        }
    }

    public void visit(Shroomer shroomer)
    {

    }
}

================
File: src/main/java/insect/RemoveInsectVisitor.java
================
package main.java.insect;

import main.java.player.*;

public class RemoveInsectVisitor implements PlayerVisitor
{
	public void visit(Insecter insecter) 
	{
		insecter.getInsects().removeIf(Insect::getDead);
	}
	
	public void visit(Shroomer shroomer) 
	{
		
	}
}

================
File: src/main/java/mushroom/CanKillStringVisitor.java
================
package main.java.mushroom;

import main.java.tecton.*;

/**
 * A CanKillStringVisitor a Visitor tervezési mintát követve
 * meghatározza, elpusztul-e egy fonal
 * az adott Tecton típuson való interakció során.
 * A logika szerint a fonal csak mérgező tektonon pusztul el idővel.
 */
public class CanKillStringVisitor implements TectonVisitor<Void> {

	private boolean canPerformAction = true;

	 /**
     * Visszaadja, hogy a fonal végrehajthat-e műveletet az utoljára meglátogatott Tecton-on.
     *
     * @return true, ha végrehajtható, különben false.
     */
	public boolean canPerformAction() {
		return canPerformAction;
	}
	
	 /**
     * A BigTecton típuson a fonal végrehajthat műveletet.
     *
     * @param big meglátogatott tekton.
     */
	@Override
	public Void visit(BigTecton big) {
		canPerformAction = false;
		return null;
	}

	 /**
     * A SmallTecton típuson a fonal végrehajthat műveletet.
     *
     * @param small meglátogatott tekton.
     */
	@Override
	public Void visit(SmallTecton small) {
		canPerformAction = false;
		return null;
	}

	 /**
     * A ToxicTecton típuson a fonal végrehajthat műveletet.
     *
     * @param toxic meglátogatott tekton.
     */
	@Override
	public Void visit(ToxicTecton toxic) {
		canPerformAction = true;
		return null;
	}

	 /**
     * A HealingTecton típuson a fonal végrehajthat műveletet.
     *
     * @param healing meglátogatott tekton.
     */
	@Override
	public Void visit(HealingTecton healing) {
		canPerformAction = false;
		return null;
	}

	 /**
     * A CoarseTecton típuson a fonal végrehajthat műveletet.
     *
     * @param coarse meglátogatott tekton.
     */
	@Override
	public Void visit(CoarseTecton coarse) {
		canPerformAction = false;
		return null;
	}
}

================
File: src/main/java/mushroom/KeepStringAliveVisitor.java
================
package main.java.mushroom;

import main.java.tecton.*;

/**
 * A StringDiesOnTectonVisitor a Visitor tervezési mintát követve
 * meghatározza, elpusztul-e egy fonal
 * az adott Tecton típuson való interakció során.
 * A logika szerint a fonal csak HealingTecton-on nem pusztul el, hiszen az életben képes azt tartani.
 */
public class KeepStringAliveVisitor implements TectonVisitor<Void> {

	private boolean canPerformAction = true;

	 /**
     * Visszaadja, hogy a fonal végrehajthat-e műveletet az utoljára meglátogatott Tecton-on.
     *
     * @return true, ha végrehajtható, különben false.
     */
	public boolean canPerformAction() {
		return canPerformAction;
	}
	
	 /**
     * A BigTecton típuson a fonal végrehajthat műveletet.
     *
     * @param big meglátogatott tekton.
     */
	@Override
	public Void visit(BigTecton big) {
		canPerformAction = false;
		return null;
	}

	 /**
     * A SmallTecton típuson a fonal végrehajthat műveletet.
     *
     * @param small meglátogatott tekton.
     */
	@Override
	public Void visit(SmallTecton small) {
		canPerformAction = false;
		return null;
	}

	 /**
     * A ToxicTecton típuson a fonal végrehajthat műveletet.
     *
     * @param toxic meglátogatott tekton.
     */
	@Override
	public Void visit(ToxicTecton toxic) {
		canPerformAction = false;
		return null;
	}

	 /**
     * A HealingTecton típuson a fonal végrehajthat műveletet.
     *
     * @param healing meglátogatott tekton.
     */
	@Override
	public Void visit(HealingTecton healing) {
		canPerformAction = true;
		return null;
	}

	 /**
     * A CoarseTecton típuson a fonal végrehajthat műveletet.
     *
     * @param coarse meglátogatott tekton.
     */
	@Override
	public Void visit(CoarseTecton coarse) {
		canPerformAction = false;
		return null;
	}
}

================
File: src/main/java/player/PlayerVisitor.java
================
package main.java.player;

/**
 * A PlayerVisitor interfész a Visitor tervezési minta része,
 * amely lehetővé teszi a különböző típusú Player objektumokon végrehajtható műveletek szétválasztását.
 * Minden implementációnak biztosítania kell a visit metódusokat az egyes játékostípusokra.
 */
public interface PlayerVisitor {
	
	/**
     * Művelet végrehajtása egy Insecter típusú játékoson.
     *
     * @param insecter az Insecter példány, amelyen a látogató műveletet hajt végre
     */
    void visit(Insecter insecter);
    /**
     * Művelet végrehajtása egy Shroomer típusú játékoson.
     *
     * @param shroomer az Shroomer példány, amelyen a látogató műveletet hajt végre
     */
    void visit(Shroomer shroomer);
}

================
File: src/main/java/spore/SporeAccept.java
================
package main.java.spore;

/** Ezt implementálja minden Spore, hogy fogadjon egy SporeVisitor-t */
public interface SporeAccept {
    void accept(SporeVisitor visitor);
}

================
File: src/main/java/spore/SporeVisitor.java
================
package main.java.spore;

/** Visitor interfész a spórák fogyasztásának kezelésére */
public interface SporeVisitor {
    void visit(FastSpore s);
    void visit(GentleSpore s);
    void visit(SlowSpore s);
    void visit(ParalyzerSpore s);
    void visit(MultiplierSpore s);
}

================
File: src/main/java/tecton/TectonVisitor.java
================
package main.java.tecton;

/**
 * Visitor interfész, amely lehetővé teszi különböző Tecton típusok meglátogatását.
 * Ez a minta külső műveletek végrehajtását segíti elő anélkül, hogy a Tecton osztályokat módosítani kellene.
 */
public interface TectonVisitor <R>{

    /**
     * Meghívódik, amikor egy BigTecton típusú objektumot látogatunk meg.
     * @param big meglátogatott BigTecton példány.
     */
    R visit(BigTecton big);

    /**
     * Meghívódik, amikor egy SmallTecton típusú objektumot látogatunk meg.
     * @param small meglátogatott SmallTecton példány.
     */
    R visit(SmallTecton small);

    /**
     * Meghívódik, amikor egy ToxicTecton típusú objektumot látogatunk meg.
     * @param toxic meglátogatott ToxicTecton példány.
     */
    R visit(ToxicTecton toxic);

    /**
     * Meghívódik, amikor egy HealingTecton típusú objektumot látogatunk meg.
     * @param healing meglátogatott HealingTecton példány.
     */
    R visit(HealingTecton healing);

    /**
     * Meghívódik, amikor egy CoarseTecton típusú objektumot látogatunk meg.
     * @param coarse meglátogatott CoarseTecton példány.
     */
    R visit(CoarseTecton coarse);
}

================
File: src/scripts/file1.txt
================
command1
command2
command3
command4
command5
help
help

================
File: src/scripts/script1.txt
================
help
help
help
exit_game

================
File: src/szoftprojlab.iml
================
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>

================
File: src/test/java/Tesztek/test10/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: SMALL
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {mb2}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb2 {
  Owner: m1
  Tecton: t2
  state: SMALL
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player sh1 {
Type: Shroomer
Name: sh1
Score: 1
Mushroom: m1
  Remaining actions: 9998
}

================
File: src/test/java/Tesztek/test10/input.txt
================
Tecton t1 small
Tecton t2 small
SetNeighbours t1 t2
Shroomer sh1
Mushroom m1 sh1
MushroomBody mb1 m1 t1 big sh1
MushroomString ms1 m1 t1 sh1
Branch ms1 t2 sh1
SpreadSpore s1 mb1 t2 fast sh1
Pass sh1
SpreadSpore s2 mb1 t2 fast sh1
Pass sh1
SpreadSpore s3 mb1 t2 fast sh1
MushroomBody mb2 m1 t2 small sh1

================
File: src/test/java/Tesztek/test11/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: SMALL
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {mb2}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb2 {
  Owner: m1
  Tecton: t2
  state: SMALL
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player sh1 {
Type: Shroomer
Name: sh1
Score: 1
Mushroom: m1
  Remaining actions: 9998
}

================
File: src/test/java/Tesztek/test11/input.txt
================
Tecton t1 small
Tecton t2 small
SetNeighbours t1 t2
Shroomer sh1
Mushroom m1 sh1
MushroomBody mb1 m1 t1 big sh1
MushroomString ms1 m1 t1 sh1
Branch ms1 t2 sh1
SpreadSpore s1 mb1 t2 gentle sh1
Pass sh1
SpreadSpore s2 mb1 t2 gentle sh1
Pass sh1
SpreadSpore s3 mb1 t2 gentle sh1
MushroomBody mb2 m1 t2 small sh1

================
File: src/test/java/Tesztek/test12/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: SMALL
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {mb2}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb2 {
  Owner: m1
  Tecton: t2
  state: SMALL
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player sh1 {
Type: Shroomer
Name: sh1
Score: 1
Mushroom: m1
  Remaining actions: 9998
}

================
File: src/test/java/Tesztek/test12/input.txt
================
Tecton t1 small
Tecton t2 small
SetNeighbours t1 t2
Shroomer sh1
Mushroom m1 sh1
MushroomBody mb1 m1 t1 big sh1
MushroomString ms1 m1 t1 sh1
Branch ms1 t2 sh1
SpreadSpore s1 mb1 t2 paralyzer sh1
Pass sh1
SpreadSpore s2 mb1 t2 paralyzer sh1
Pass sh1
SpreadSpore s3 mb1 t2 paralyzer sh1
MushroomBody mb2 m1 t2 small sh1

================
File: src/test/java/Tesztek/test13/expected.txt
================
Current round: 2

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {ms1}
  Insects: {i1}
  Spores: {}
}
1. Insect i1 {
  Tecton: t2
  Nutrients: 0
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
}
2. Player is1 {
Type: Insecter
Name: is1
Score: 0
Insects:
 - i1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test13/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s1
Insecter is1
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
MushroomString ms1 m1 t1 s1
Branch ms1 t2 s1
Insect i1 t1 is1
pass s1
Move i1 t2 is1

================
File: src/test/java/Tesztek/test14/expected.txt
================
Current round: 2

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {ms1}
  Insects: {i1}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {ms1_clone1}
  Insects: {}
  Spores: {}
}
1. Insect i1 {
  Tecton: t1
  Nutrients: 0
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1}
  Neighbours: {}
  is dead? no
}
2. MushroomString ms1_clone1 {
  Mushroom: m1
  Connections: {t2}
  Neighbours: {}
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
}
2. Player is1 {
Type: Insecter
Name: is1
Score: 0
Insects: 
 - i1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test14/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s1
Insecter is1
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
MushroomString ms1 m1 t1 s1
Branch ms1 t2 s1
Insect i1 t1 is1
Pass s1
Cut i1 ms1 is1

================
File: src/test/java/Tesztek/test15/expected.txt
================
Current round: 2

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {i1}
  Spores: {}
}
1. Insect i1 {
  Tecton: t2
  Nutrients: 1
  Effect: FAST
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
}
2. Player is1 {
Type: Insecter
Name: is1
Score: 0
Insects: 
 - i1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test15/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s1
Insecter is1
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 fast s1
Insect i1 t2 is1
pass s1
Consume i1 sp1 is1

================
File: src/test/java/Tesztek/test16/expected.txt
================
Current round: 2

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {i1}
  Spores: {}
}
1. Insect i1 {
  Tecton: t2
  Nutrients: 2
  Effect: SLOW
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
}
2. Player is1 {
Type: Insecter
Name: is1
Score: 0
Insects: 
 - i1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test16/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s1
Insecter is1
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 slow s1
Insect i1 t2 is1
pass s1
Consume i1 sp1 is1

================
File: src/test/java/Tesztek/test17/expected.txt
================
Current round: 2

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {i1}
  Spores: {}
}
1. Insect i1 {
  Tecton: t2
  Nutrients: 2
  Effect: PARALYZED
  can move? no
  can cut string? yes
  is dead? no
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
}
2. Player is1 {
Type: Insecter
Name: is1
Score: 0
Insects: 
 - i1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test17/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s1
Insecter is1
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 paralyzer s1
Insect i1 t2 is1
pass s1
Consume i1 sp1 is1

================
File: src/test/java/Tesztek/test18/expected.txt
================
Current round: 2

1. Tecton t {
  Type: BIG
  Neighbours: {}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {in}
  Spores: {}
}
1. Insect in {
  Tecton: t
  Nutrients: 0
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m {
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
}
2. Player i {
Type: Insecter
Name: i
Score: 0
Insects: 
 - in
  Remaining actions: 10000
}

================
File: src/test/java/Tesztek/test18/input.txt
================
Shroomer s
Insecter i
Tecton t big
Mushroom m s
Insect in t i
pass s

================
File: src/test/java/Tesztek/test19/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}

================
File: src/test/java/Tesztek/test19/input.txt
================
Tecton t big
Split t t1 t2

================
File: src/test/java/Tesztek/test2/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {sp1}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? no
  remaining sporulations: 2
  is dead? no
}
1. Spore sp1 {
  Mushroom: m1
  Tecton: t2
  Nutrient value: 1
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test2/input.txt
================
Shroomer s1
Tecton t1 big
Tecton t2 small
SetNeighbours t1 t2
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 fast s1
List

================
File: src/test/java/Tesztek/test20/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: SMALL
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}

================
File: src/test/java/Tesztek/test20/input.txt
================
Tecton t small
Split t t1 t2

================
File: src/test/java/Tesztek/test21/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: TOXIC
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: TOXIC
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}

================
File: src/test/java/Tesztek/test21/input.txt
================
Tecton t toxic
Split t t1 t2

================
File: src/test/java/Tesztek/test22/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: COARSE
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: COARSE
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}

================
File: src/test/java/Tesztek/test22/input.txt
================
Tecton t coarse
Split t t1 t2

================
File: src/test/java/Tesztek/test23/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: HEALING
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: HEALING
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}

================
File: src/test/java/Tesztek/test23/input.txt
================
Tecton t healing
Split t t1 t2

================
File: src/test/java/Tesztek/test24/expected.txt
================
Current round: 5

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {ms}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {mb}
  MushroomStrings: {ms}
  Insects: {}
  Spores: {}
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t2
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms {
  Mushroom: m
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 1
Mushroom: m
  Remaining actions: 10000
}

================
File: src/test/java/Tesztek/test24/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s
Mushroom m s
MushroomBody mb m t1 big s
MushroomString ms m t1 s
Branch ms t2 s
SpreadSpore spore1 mb t2 multiplier s
pass s
SpreadSpore spore2 mb t2 multiplier s
pass s
SpreadSpore spore3 mb t2 multiplier s
MushroomBody mb m t2 small s
pass s
pass s

================
File: src/test/java/Tesztek/test25/expected.txt
================
Current round: 2

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb}
  MushroomStrings: {ms}
  Insects: {in}
  Spores: {}
}
2. Tecton t2 {
  Type: HEALING
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {ms_clone2}
  Insects: {}
  Spores: {}
}
1. Insect in {
  Tecton: t1
  Nutrients: 0
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms {
  Mushroom: m
  Connections: {t1}
  Neighbours: {}
  is dead? no
}
2. MushroomString ms_clone2 {
  Mushroom: m
  Connections: {t2}
  Neighbours: {}
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
}
2. Player i {
Type: Insecter
Name: i
Score: 0
Insects:
 - in
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test25/input.txt
================
tecton t1 big
tecton t2 healing
SetNeighbours t1 t2
shroomer s
mushroom m s
mushroombody mb m t1 big s
mushroomstring ms m t1 s
branch ms t2 s
insecter i
insect in t1 i
pass s
cut in ms i

================
File: src/test/java/Tesztek/test26/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb}
  MushroomStrings: {ms}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {m_body1}
  MushroomStrings: {ms}
  Insects: {in}
  Spores: {}
}
1. Insect in {
  Tecton: t2
  Nutrients: 2
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? yes
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 2
  is dead? no
}
2. MushroomBody m_body1 {
  Owner: m
  Tecton: t2
  state: MEDIUM
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms {
  Mushroom: m
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
  Remaining actions: 10000
}
2. Player i {
Type: Insecter
Name: i
Score: 0
Insects: 
 - in
}

================
File: src/test/java/Tesztek/test26/input.txt
================
tecton t1 big
tecton t2 big
Shroomer s
Mushroom m s
MushroomBody mb m t1 big s
MushroomString ms m t1 s
setneighbours t1 t2
Insecter i
Insect in t2 i
branch ms t2 s
spreadspore spore mb t2 paralyzer s
pass s
consume in spore i
pass i
list

================
File: src/test/java/Tesztek/test27/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {spore}
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t1
  state: BIG
  spores available? no
  remaining sporulations: 2
  is dead? no
}
1. Spore spore {
  Mushroom: m
  Tecton: t2
  Nutrient value: 2
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test27/input.txt
================
tecton t1 big
tecton t2 big
SetNeighbours t1 t2
shroomer s
mushroom m s
mushroombody mb m t1 big s
spreadspore spore mb t2 multiplier s

================
File: src/test/java/Tesztek/test28/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {ms}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {mb}
  MushroomStrings: {ms}
  Insects: {}
  Spores: {}
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t2
  state: SMALL
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms {
  Mushroom: m
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 1
Mushroom: m
  Remaining actions: 9998
}

================
File: src/test/java/Tesztek/test28/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer s
Mushroom m s
MushroomBody mb m t1 big s
MushroomString ms m t1 s
Branch ms t2 s
SpreadSpore spore1 mb t2 multiplier s
pass s
SpreadSpore spore2 mb t2 multiplier s
pass s
SpreadSpore spore3 mb t2 multiplier s
MushroomBody mb m t2 small s

================
File: src/test/java/Tesztek/test29/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: BIG
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {in, in_clone1}
  Spores: {}
}
1. Insect in {
  Tecton: t2
  Nutrients: 2
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? no
}
2. Insect in_clone1 {
  Tecton: t2
  Nutrients: 0
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? no
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 2
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
}
2. Player i {
Type: Insecter
Name: i
Score: 0
Insects: 
 - in
 - in_clone1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test29/input.txt
================
tecton t1 big
tecton t2 big
SetNeighbours t1 t2
shroomer s
mushroom m s
mushroombody mb m t1 big s
spreadspore spore mb t2 multiplier s
pass s
insecter i
insect in t2 i
pass s
consume in spore i

================
File: src/test/java/Tesztek/test3/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {sp1}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? no
  remaining sporulations: 2
  is dead? no
}
1. Spore sp1 {
  Mushroom: m1
  Tecton: t2
  Nutrient value: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test3/input.txt
================
Shroomer s1
Tecton t1 big
Tecton t2 small
SetNeighbours t1 t2
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 slow s1
List

================
File: src/test/java/Tesztek/test30/expected.txt
================
Current round: 4

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb}
  MushroomStrings: {ms}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: TOXIC
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms {
  Mushroom: m
  Connections: {t1}
  Neighbours: {}
  is dead? no
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
  Remaining actions: 10000
}

================
File: src/test/java/Tesztek/test30/input.txt
================
tecton t1 big
tecton t2 toxic
SetNeighbours t1 t2
shroomer s
mushroom m s
mushroombody mb m t1 big s
mushroomstring ms m t1 s
branch ms t2 s
pass s
pass s
pass s

================
File: src/test/java/Tesztek/test31/expected.txt
================
Current round: 0

1. Tecton splittedt1 {
  Type: BIG
  Neighbours: {splittedt2}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton splittedt2 {
  Type: BIG
  Neighbours: {splittedt1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
1. Insect in {
  Tecton: t
  Nutrients: 0
  Effect: NO EFFECT
  can move? yes
  can cut string? yes
  is dead? yes
}
1. Mushroom m {
  is dead? no
}
1. MushroomBody mb {
  Owner: m
  Tecton: t
  spores available? yes
  remaining sporulations: 3
  is dead? yes
}
1. Player s {
Type: Shroomer
Name: s
Score: 0
Mushroom: m
  Remaining actions: 10000
}
2. Player i {
Type: Insecter
Name: i
Score: 0
Insects: 
 - in
}

================
File: src/test/java/Tesztek/test31/input.txt
================
Shroomer s
Insecter i
Tecton t big
Insect in t i
Mushroom m s
MushroomBody mb m t big s
Split t splittedt1 splittedt2

================
File: src/test/java/Tesztek/test4/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {sp1}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? no
  remaining sporulations: 2
  is dead? no
}
1. Spore sp1 {
  Mushroom: m1
  Tecton: t2
  Nutrient value: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test4/input.txt
================
Shroomer s1
Tecton t1 big
Tecton t2 small
SetNeighbours t1 t2
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 paralyzer s1
List

================
File: src/test/java/Tesztek/test5/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {sp1}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? no
  remaining sporulations: 2
  is dead? no
}
1. Spore sp1 {
  Mushroom: m1
  Tecton: t2
  Nutrient value: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test5/input.txt
================
Shroomer s1
Tecton t1 big
Tecton t2 small
SetNeighbours t1 t2
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 gentle s1
List

================
File: src/test/java/Tesztek/test6/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {t2}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {}
  MushroomStrings: {}
  Insects: {}
  Spores: {sp1}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? no
  remaining sporulations: 2
  is dead? no
}
1. Spore sp1 {
  Mushroom: m1
  Tecton: t2
  Nutrient value: 2
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
  Remaining actions: 9999
}

================
File: src/test/java/Tesztek/test6/input.txt
================
Shroomer s1
Tecton t1 big
Tecton t2 small
SetNeighbours t1 t2
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
SpreadSpore sp1 mb1 t2 multiplier s1
List

================
File: src/test/java/Tesztek/test7/expected.txt
================
Current round: 1

1. Tecton t1 {
  Type: BIG
  Neighbours: {}
  MushroomBodies: {mb1}
  MushroomStrings: {}
  Insects: {}
  Spores: {}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. Player s1 {
Type: Shroomer
Name: s1
Score: 0
Mushroom: m1
  Remaining actions: 10000
}

================
File: src/test/java/Tesztek/test7/input.txt
================
Shroomer s1
Tecton t1 big
Mushroom m1 s1
MushroomBody mb1 m1 t1 big s1
List

================
File: src/test/java/Tesztek/test8/expected.txt
================
Current round: 1

1. Tecton t1 {
Type: BIG
Neighbours: {t2}
MushroomBodies: {mb1}
MushroomStrings: {ms1}
Insects: {}
Spores: {}
}
2. Tecton t2 {
Type: BIG
Neighbours: {t1}
MushroomBodies: {}
MushroomStrings: {ms1}
Insects: {}
Spores: {}
}
1. Mushroom m1 {
is dead? no
}
1. MushroomBody mb1 {
  Owner: m1
  Tecton: t1
  state: BIG
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player sh1 {
Type: Shroomer
Name: sh1
Score: 0
Mushroom: m1
  Remaining actions: 9998
}

================
File: src/test/java/Tesztek/test8/input.txt
================
Tecton t1 big
Tecton t2 big
SetNeighbours t1 t2
Shroomer sh1
Mushroom m1 sh1
MushroomBody mb1 m1 t1 big sh1
MushroomString ms1 m1 t1 sh1
Branch ms1 t2 sh1

================
File: src/test/java/Tesztek/test9/expected.txt
================
Current round: 3

1. Tecton t1 {
  Type: SMALL
  Neighbours: {t2}
  MushroomBodies: {}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
2. Tecton t2 {
  Type: SMALL
  Neighbours: {t1}
  MushroomBodies: {mb2}
  MushroomStrings: {ms1}
  Insects: {}
  Spores: {}
}
1. Mushroom m1 {
  is dead? no
}
1. MushroomBody mb2 {
  Owner: m1
  Tecton: t2
  state: SMALL
  spores available? yes
  remaining sporulations: 3
  is dead? no
}
1. MushroomString ms1 {
  Mushroom: m1
  Connections: {t1, t2}
  Neighbours: {}
  is dead? no
}
1. Player sh1 {
Type: Shroomer
Name: sh1
Score: 1
Mushroom: m1
  Remaining actions: 9998
}

================
File: src/test/java/Tesztek/test9/input.txt
================
Tecton t1 small
Tecton t2 small
SetNeighbours t1 t2
Shroomer sh1
Mushroom m1 sh1
MushroomBody mb1 m1 t1 big sh1
MushroomString ms1 m1 t1 sh1
Branch ms1 t2 sh1
SpreadSpore s1 mb1 t2 slow sh1
Pass sh1
SpreadSpore s2 mb1 t2 slow sh1
Pass sh1
SpreadSpore s3 mb1 t2 slow sh1
MushroomBody mb2 m1 t2 small sh1

================
File: szoftprojlab.iml
================
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>

================
File: szoftprojlabGrafikus.iml
================
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>

================
File: src/main/java/console/Commands.java
================
package main.java.console;

import main.java.GameFileChooser;

import java.io.*;
import java.util.HashSet;
import java.util.Set;

/**
 * A játék konzol parancsait kezelő osztály.
 * Végrehajtja a különböző játékbeli műveleteket a konzol parancsok alapján.
 */
public class Commands {
    private static int numMakeEnd = 0;
    private final ConsoleHandler consoleHandler;
    private static final String SAVE_PATH = "src/save/";
    private static final String SCRIPTS_PATH = "src/scripts/";

    public Commands(ConsoleHandler consoleHandler) {
        this.consoleHandler = consoleHandler;
    }

    /**
     * Új objektumot vagy entitást ad a játékhoz.
     */
    public void add() {

    }

    public void saveFile(String filename) {
        if(GameFileChooser.saveGame(null,null)) {
            consoleHandler.printToConsole("Game saved to " + filename);
        } else {
            consoleHandler.printToConsole("Game couldn't be saved to " + filename);
        }
    }

    public void loadFile(String filename) {
        if(GameFileChooser.loadGame(null,null)) {
            consoleHandler.printToConsole("Game loaded from " + filename);
        } else {
            consoleHandler.printToConsole("Game couldn't be loaded from " + filename);
        }
    }

    public void createFile(String filename, ConsoleGUI gui) {
        new Thread(() -> {
            File saveFile = new File(SCRIPTS_PATH + filename + ".txt");
            try (BufferedWriter fileWriter = new BufferedWriter(new FileWriter(saveFile))) {
                consoleHandler.printToConsole("Enter commands for the script (type 'end' to finish):");
                while (true) {
                    String input = gui.getInput();
                    if(input.startsWith("make")){
                        numMakeEnd++;
                    }
                    if ("end".equalsIgnoreCase(input.trim())) {
                        if(numMakeEnd <= 0) {
                            consoleHandler.printToConsole(filename + " created and saved successfully.");
                            break;
                        } else {
                            numMakeEnd--;
                        }
                    }
                    fileWriter.write(input);
                    fileWriter.newLine();
                }
            } catch (IOException e) {
                consoleHandler.printToConsole("An error occurred while writing to the file: " + e.getMessage());
            }
        }).start();
    }

    public void runScript(String filename) {
        runScript(filename, new HashSet<>());
    }

    /**
     * Végrehajtja a script fájlban található parancsokat.
     * @param filename a script fájl neve
     */
    private void runScript(String filename, Set<String> visitedScripts) {
        String normalizedFilename = SCRIPTS_PATH + filename + ".txt";

        if (visitedScripts.contains(normalizedFilename)) {
            consoleHandler.printToConsole(
            "\n----------------------------------------------------------\n" +
            "ERROR: Circular script reference detected: " + filename +
            "\n----------------------------------------------------------");
            return;
        }
        visitedScripts.add(normalizedFilename);
        File scriptFile = new File(normalizedFilename);
        if (!scriptFile.exists() || !scriptFile.isFile()) {
            consoleHandler.printToConsole("ERROR: " + filename + " not found");
            return;
        }
        try (BufferedReader fileReader = new BufferedReader(new FileReader(scriptFile))) {
            String line;
            while ((line = fileReader.readLine()) != null) {
                line = line.trim();
                if (line.startsWith("script")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length == 2) {
                        runScript(parts[1], visitedScripts);
                    } else {
                        consoleHandler.printToConsole("Invalid script command: " + line);
                    }
                } else if(line.startsWith("make")){
                    String[] parts = line.split("\\s+");
                    String newFileName = parts[1];
                    File saveFile = new File(SCRIPTS_PATH + newFileName + ".txt");
                    try (BufferedWriter fileWriter = new BufferedWriter(new FileWriter(saveFile))) {
                        consoleHandler.printToConsole("|Entering make mode: " + newFileName + "|");
                        while (true) {
                            String input = fileReader.readLine();
                            if (input.equalsIgnoreCase("end") || input.startsWith("end")) {
                                fileWriter.write(input);
                                fileWriter.newLine();
                                consoleHandler.printToConsole("|" + newFileName + " created and saved|");
                                break;
                            }
                            fileWriter.write(input);
                            fileWriter.newLine();
                        }
                    } catch (IOException e) {
                        consoleHandler.printToConsole("An error occurred while writing to the file: " + e.getMessage());
                    }
                } else {
                    consoleHandler.executeCommand(line);
                }
            }
        } catch (IOException e) {
            consoleHandler.printToConsole("An error occurred while reading the script file: " + e.getMessage());
        }
        visitedScripts.remove(normalizedFilename);
        consoleHandler.printToConsole("Finished executing script: " + filename);
    }

    public void printHelp(String command) {
        switch(command){
            case "script" -> consoleHandler.printToConsole("Script use: script <filename> without extension");
            case "make" -> consoleHandler.printToConsole("Make use: make <filename> without extension");
            case "add" -> consoleHandler.printToConsole("");
            case "remove" -> consoleHandler.printToConsole("");
            case "reset" -> consoleHandler.printToConsole("Reset use: reset -resets the game");
            case "save" -> consoleHandler.printToConsole("Save use: save <filename> without extension");
            case "load" -> consoleHandler.printToConsole("Load use: load <filename> without extension");
            case "exit" -> consoleHandler.printToConsole("Exit use: exit - exits console mode");
            case "exit_game" -> consoleHandler.printToConsole("Exits game");
            default -> consoleHandler.printToConsole("""
                    script/make/set/get/add/reset
                    save/load/exit/exit_game/remove
                    | Use 'help <command>' from above commands |
                    """);
        }
    }

    public void setGameValue() {

    }

    public void getGameValue() {

    }
}

================
File: src/main/java/console/ConsoleGUI.java
================
package main.java.console;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import javax.swing.*;

/**
 * A játék konzol felhasználói felületét megvalósító osztály.
 * Kezeli a bevitelt és megjeleníti a konzol kimenetét.
 */
public class ConsoleGUI extends JFrame {

    private final JTextPane outputPane;
    private final JTextField inputField;
    private final ConsoleHandler consoleHandler;
    private final ScriptModeDocument document;
    private final BlockingQueue<String> inputQueue;
    private final CommandHistory commandHistory;
    private final CommandCompleter commandCompleter;
    private volatile boolean isScriptMode;
    private boolean isLastCompletionSame = false;
    private String lastCompletedInput = "";
    private static int numOfMakeEnd = 0;


    public ConsoleGUI(ConsoleHandler consoleHandler) {
        super("Developer Console");
        this.consoleHandler = consoleHandler;
        this.commandHistory = new CommandHistory();
        this.inputQueue = new LinkedBlockingQueue<>();
        this.isScriptMode = false;
        this.document = new ScriptModeDocument();
        this.commandCompleter = new CommandCompleter();

        setSize(600, 400);
        setResizable(true);
        setLocationRelativeTo(null);

        outputPane = new JTextPane(document);
        outputPane.setEditable(false);
        outputPane.setBackground(new Color(30, 30, 30));
        outputPane.setMargin(new Insets(5, 5, 5, 5));

        JScrollPane scrollPane = new JScrollPane(outputPane);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        inputField = new JTextField();
        inputField.setBackground(new Color(40, 40, 40));
        inputField.setForeground(Color.WHITE);
        inputField.setCaretColor(Color.WHITE);
        inputField.setFont(new Font("Consolas", Font.PLAIN, 14));
        inputField.setMargin(new Insets(5, 5, 5, 5));

        setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, Collections.emptySet());
        inputField.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, Collections.emptySet());


        setLayout(new BorderLayout());
        add(scrollPane, BorderLayout.CENTER);

        JPanel inputPanel = new JPanel(new BorderLayout());
        inputPanel.setBackground(new Color(40, 40, 40));
        JLabel promptLabel = new JLabel("> ");
        promptLabel.setForeground(Color.GREEN);
        promptLabel.setFont(new Font("Consolas", Font.PLAIN, 14));
        promptLabel.setBackground(new Color(40, 40, 40));
        promptLabel.setOpaque(true);
        inputPanel.add(promptLabel, BorderLayout.WEST);
        inputPanel.add(inputField, BorderLayout.CENTER);
        add(inputPanel, BorderLayout.SOUTH);

        inputField.addActionListener(e -> handleInput());

        inputField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                switch (e.getKeyCode()) {
                    case KeyEvent.VK_UP :
                        inputField.setText(commandHistory.getPrevious());
                        break;
                    case KeyEvent.VK_DOWN :
                        inputField.setText(commandHistory.getNext());
                        break;
                    case KeyEvent.VK_ESCAPE :
                        dispose();
                        break;
                    case KeyEvent.VK_TAB :
                        e.consume();
                        handleTabCompletion();
                        break;
                }
            }
        });

        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                if (isScriptMode) {
                    inputQueue.offer("end");
                }
                dispose();
            }
        });

        inputField.getInputMap().put(KeyStroke.getKeyStroke("TAB"), "complete");
        inputField.getActionMap().put("complete", new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleTabCompletion();
            }
        });

        inputField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                switch (e.getKeyCode()) {
                    case KeyEvent.VK_UP :
                        inputField.setText(commandHistory.getPrevious());
                        break;
                    case KeyEvent.VK_DOWN :
                        inputField.setText(commandHistory.getNext());
                        break;
                    case KeyEvent.VK_ESCAPE :
                        dispose();
                        break;
                }
            }
        });
    }

    private void resetMakeEndNum() {
        numOfMakeEnd = 0;
    }

    /**
     * Kezeli a parancsbevitelt.
     * Feldolgozza a beírt parancsot és végrehajtja azt.
     */
    private void handleInput() {
        String input = inputField.getText().trim();
        if (!input.isEmpty()) {
            commandHistory.add(input);
            if (isScriptMode) {
                document.appendUserInput(input, true);
                inputQueue.offer(input);
                if(input.startsWith("make")){
                    numOfMakeEnd++;
                }
                if (input.equalsIgnoreCase("end")) {
                    if(numOfMakeEnd <= 0) {
                        isScriptMode = false;
                        document.resetLineNumber();
                        document.appendPrompt();
                    } else{
                        numOfMakeEnd--;
                    }
                }
            } else {
                document.appendPrompt();
                document.appendUserInput(input, false);
                if (input.startsWith("make")) {
                    numOfMakeEnd++;
                    isScriptMode = true;
                    document.resetLineNumber();
                    resetMakeEndNum();
                    document.appendSystemMessage("Enter commands for the script (type 'end' to finish):");
                }
                consoleHandler.executeCommand(input);
            }
            inputField.setText("");
            scrollToBottom();
        }
    }

    private void handleTabCompletion() {
        String currentInput = inputField.getText().trim();
        if (currentInput.isEmpty()) {
            return;
        }
        if (!currentInput.equals(lastCompletedInput)) {
            isLastCompletionSame = false;
        }
        boolean endsWithSpace = inputField.getText().endsWith(" ");
        String[] parts = currentInput.split("\\s+");
        String completed;
        if (endsWithSpace || parts.length > 1) {
            String mainCommand = parts[0].toLowerCase();
            String partial = parts.length > 1 ? parts[1].toLowerCase() : "";
            completed = commandCompleter.complete(mainCommand + " " + partial, isLastCompletionSame);

            int lastSpaceIndex = completed.lastIndexOf(' ');
            String prefix = parts[0] + " ";
            inputField.setText(prefix + completed.substring(lastSpaceIndex + 1));
        }
        else {
            completed = commandCompleter.complete(currentInput, isLastCompletionSame);
            inputField.setText(completed);
        }
        isLastCompletionSame = true;
        lastCompletedInput = inputField.getText().trim();
        inputField.setCaretPosition(inputField.getText().length());
        inputField.requestFocusInWindow();
    }

    private void scrollToBottom() {
        outputPane.setCaretPosition(document.getLength());
    }

    public void appendToConsole(String text) {
        SwingUtilities.invokeLater(() -> {
            document.appendSystemMessage(text);
            if (isScriptMode) {
                scrollToBottom();
            } else {
                document.appendPrompt();
                scrollToBottom();
            }
        });
    }

    public String getInput() {
        try {
            return inputQueue.take();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return "end";
        }
    }

    private static class CommandHistory {
        private final List<String> history = new ArrayList<>();
        private int currentIndex = -1;

        public void add(String command) {
            history.add(command);
            currentIndex = history.size();
        }

        public String getPrevious() {
            if (currentIndex > 0) {
                currentIndex--;
                return history.get(currentIndex);
            }
            return currentIndex > -1 ? history.get(currentIndex) : "";
        }

        public String getNext() {
            if (currentIndex < history.size() - 1) {
                currentIndex++;
                return history.get(currentIndex);
            }
            if (currentIndex == history.size() - 1) {
                currentIndex++;
                return "";
            }
            return "";
        }
    }

    public void showConsole() {
        setVisible(true);
        inputField.requestFocus();
    }

}

================
File: src/main/java/console/ConsoleHandler.java
================
package main.java.console;

import java.util.HashMap;
import java.util.Map;

/**
 * A konzol parancsok kezelését végző osztály.
 * Összeköti a felhasználói felületet a parancsok végrehajtásával.
 */
public class ConsoleHandler {

    public boolean abortProcess;
    private ConsoleGUI consoleGUI;
    private final Commands commands;
    private final Map<String, Command> commandMap;

    public ConsoleHandler() {
        this.commands = new Commands(this);
        this.abortProcess = false;
        this.commandMap = initializeCommands();
    }

    public void printToConsole(String message) {
        if (consoleGUI != null && consoleGUI.isVisible()) {
            consoleGUI.appendToConsole(message);
        }
    }

    /**
     * Inicializálja a parancsokat.
     * Beállítja a parancsokhoz tartozó végrehajtási logikát.
     * @return a parancsok térképe
     */
    private Map<String, Command> initializeCommands() {
        Map<String, Command> map = new HashMap<>();

        map.put("help", args -> {
            if (args.length < 2) {
                String helpText = getHelpText();
                printToConsole(helpText);
            } else {
                commands.printHelp(args[1]);
            }
        });

        map.put("reset", e -> {
            //RESTARTOLNI KELL A GAMET
            printToConsole("Game has been reset");
        });

        map.put("exit", e -> {
            abortProcess = true;
            if (consoleGUI != null) {
                consoleGUI.dispose();
            }
        });

        map.put("exit_game", e -> System.exit(0));

        map.put("remove", args -> {
            if (args.length == 2) {

            } else {
                printToConsole("Invalid format! Use 'help remove' for correct usage");
            }
        });

        map.put("save", args -> {
            if (args.length == 2) {
                commands.saveFile(args[1]);
            } else {
                printToConsole("Invalid format! Use 'help save' for correct usage");
            }
        });

        map.put("load", args -> {
            if (args.length == 2) {
                commands.loadFile(args[1]);
            } else {
                printToConsole("Invalid format! Use 'help load' for correct usage");
            }
        });

        map.put("set", args -> {
            switch (args.length) {
                case 4 -> {
                    if (args[1].equals("player")) {
                        commands.setGameValue();
                    } else if (args[1].equals("entity")) {
                    } else {
                    }
                }
                case 3 -> commands.setGameValue();
                default -> printToConsole("""
                    Invalid format for 'set' command.
                    Usage: set entity arg1 value
                    Entity types: *Enemy, Player
                    Arguments: speed, health, maxhealth""");
            }
        });

        map.put("get", args -> {
            switch (args.length) {
                case 3 -> {
                    switch (args[1]) {
                        default -> printToConsole("Unknown entity type! Use 'help' for available commands");
                    }
                }
                case 2 -> commands.getGameValue();
                default -> printToConsole("""
                    Invalid format for 'get' command.
                    Usage: get entity arg1
                    Entity types: *Enemy, Player
                    Arguments: speed, health""");
            }
        });

        map.put("add", args -> {
        });

        map.put("script", args -> {
            if (args.length == 2) {
                commands.runScript(args[1]);
            } else {
                printToConsole("Invalid format! Use 'help script' for correct usage");
            }
        });

        map.put("make", args -> {
            if (args.length == 2) {
                commands.createFile(args[1], consoleGUI);
            } else {
                printToConsole("Invalid format! Use 'help make' for correct usage");
            }
        });

        return map;
    }

    public void startConsoleInput() {
        if (consoleGUI == null) {
            consoleGUI = new ConsoleGUI(this);
        }
        consoleGUI.showConsole();
        consoleGUI.appendToConsole(getHelpText());
    }

    public void executeCommand(String input) {
        if (input.isEmpty()) return;
        String[] parts = input.trim().toLowerCase().split("\\s+");
        Command command = commandMap.get(parts[0]);
        if (command != null) {
            try {
                command.execute(parts);
            } catch (Exception exc) {
                printToConsole("Error executing command: " + exc.getMessage());
            }
        } else {
            printToConsole("Unknown command. Type 'help' for available commands.");
        }
    }

    private String getHelpText() {
        return """
                            Available commands:
            -------------------------------------------------------
            | help [command] : Show help for a specific command   |
            | reset          : Reset the game                     |
            | remove         : Remove entities                    |
            | save/load      : Save/Load game state               |
            | add            : Add entities or objects            |
            | script         : Run a script file                  |
            | make           : Create a new script file           |
            | exit           : Exit console mode                  |
            | exit_game      : Exit the game                      |
            -------------------------------------------------------
            Type 'help <command>' for detailed usage information.""";
    }
}

================
File: src/main/java/console/ScriptModeDocument.java
================
package main.java.console;

import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import java.awt.*;

/**
 * A script módban használt dokumentum osztály.
 * Kezeli a script szerkesztés speciális megjelenítését.
 */
public class ScriptModeDocument extends DefaultStyledDocument {

    private int lineNumber = 1;
    private final Style promptStyle;
    private final Style numberStyle;
    private final Style textStyle;
    private final Style scriptModeStyle;
    private final Style systemStyle;

    public ScriptModeDocument() {
        promptStyle = addStyle("prompt", null);
        StyleConstants.setForeground(promptStyle, Color.GREEN);
        StyleConstants.setFontFamily(promptStyle, "Consolas");
        StyleConstants.setFontSize(promptStyle, 14);

        numberStyle = addStyle("number", null);
        StyleConstants.setForeground(numberStyle, new Color(150, 150, 150));
        StyleConstants.setFontFamily(numberStyle, "Consolas");
        StyleConstants.setFontSize(numberStyle, 14);

        textStyle = addStyle("text", null);
        StyleConstants.setForeground(textStyle, Color.WHITE);
        StyleConstants.setFontFamily(textStyle, "Consolas");
        StyleConstants.setFontSize(textStyle, 14);

        scriptModeStyle = addStyle("scriptMode", null);
        StyleConstants.setForeground(scriptModeStyle, new Color(135, 206, 235));
        StyleConstants.setFontFamily(scriptModeStyle, "Consolas");
        StyleConstants.setFontSize(scriptModeStyle, 14);

        systemStyle = addStyle("system", null);
        StyleConstants.setForeground(systemStyle, new Color(200, 200, 200));
        StyleConstants.setFontFamily(systemStyle, "Consolas");
        StyleConstants.setFontSize(systemStyle, 14);
    }

    /**
     * Hozzáad egy prompt karaktert a dokumentumhoz.
     */
    public void appendPrompt() {
        try {
            insertString(getLength(), "> ", promptStyle);
        } catch (BadLocationException e) {

        }
    }

    /**
     * Hozzáad egy felhasználói bevitelt a dokumentumhoz.
     * @param text a bevitt szöveg
     * @param isScriptMode jelzi, hogy script módban vagyunk-e
     */
    public void appendUserInput(String text, boolean isScriptMode) {
        try {
            if (isScriptMode) {
                insertString(getLength(), lineNumber + ". ", numberStyle);
                insertString(getLength(), text + "\n", scriptModeStyle);
                lineNumber++;
            } else {
                insertString(getLength(), text + "\n", textStyle);
            }
        } catch (BadLocationException e) {

        }
    }

    public void appendSystemMessage(String text) {
        try {
            insertString(getLength(), text + "\n", systemStyle);
        } catch (BadLocationException e) {

        }
    }


    public void resetLineNumber() {
        lineNumber = 1;
    }
}

================
File: src/main/java/mushroom/CanGrowBodyVisitor.java
================
package main.java.mushroom;

import main.java.tecton.*;

/**
 * Visitor implementáció, amely meghatározza, hogy egy adott Tecton típuson 
 * lehet-e gombatest növesztését kezdeményezni.
 * A döntést a 'canPerformAction' logikai érték reprezentálja.
 */
public class CanGrowBodyVisitor implements TectonVisitor<Void> {

	private boolean canPerformAction = true;
	
	/**
     * Eredmény lekérdezése: az utolsó meglátogatott Tecton típus alapján
     * visszaadja, hogy azon lehet-e testet növeszteni.
     */
    public boolean canPerformAction() { return canPerformAction; }

    @Override
    public Void visit(BigTecton big) {
        canPerformAction = big.hasSpace();
		return null;
    }
    
    @Override
    public Void visit(SmallTecton small) {
        canPerformAction = small.hasSpace();
		return null;
    }
    
    @Override
    public Void visit(ToxicTecton toxic) {
        canPerformAction = toxic.hasSpace();
		return null;
    }
    
    @Override
    public Void visit(HealingTecton healing) {
        canPerformAction = healing.hasSpace();
		return null;
    }
    
    @Override
    public Void visit(CoarseTecton coarse) {
        canPerformAction = false;  // Coarse sose engedi
		return null;
    }
}

================
File: src/main/java/Nameable.java
================
package main.java;

/**
 * Egy absztrakt osztály, amely névvel rendelkező objektumokat reprezentál.
 * Az osztály egy String name mezőt tartalmaz, valamint getter és setter metódusokat
 * a név eléréséhez és módosításához.
 */ 
public abstract class Nameable {

	private String name;

	public String getName(){
		return name;
	}

	public void setName(String name){
		this.name = name;
	}

}

================
File: src/main/java/player/PlayerAccept.java
================
package main.java.player;

/**
 * A PlayerAccept interfészt minden olyan osztálynak implementálnia kell,
 * amely elfogad egy PlayerVisitor látogatót a Visitor tervezési minta szerint.
 * Ez lehetővé teszi, hogy különböző Player típusok viselkedése
 * bővíthető legyen anélkül, hogy módosítani kellene őket.
 */
public interface PlayerAccept 
{
	/**
     * Elfogad egy PlayerVisitor látogatót, és meghívja rajta a megfelelő
     * visit metódust az aktuális objektum típusának megfelelően.
     *
     * @param visitor a látogató, amely műveletet hajt végre az objektumon
     */
	void accept(PlayerVisitor visitor);
}

================
File: src/main/java/spore/FastSpore.java
================
package main.java.spore;

import main.java.tecton.*;
import main.java.insect.Insect;
import main.java.mushroom.Mushroom;

/**
 * A FastSpore osztály egy gyorsító hatású spórát reprezentál, amely egy rovarral 
 * történő találkozás esetén megnöveli annak sebességét.
 */
public class FastSpore extends Spore implements SporeAccept {
	/**
     * Konstruktor, amely inicializálja a gyorsító spórát.
     * 
     * @param nutrientValue   A spóra által biztosított tápanyag értéke.
     * @param mushroom        A gomba, amelyből a spóra származik.
     * @param location        A Tecton, ahol a spóra található.
     * @param name            A spóra neve.
     */
	public FastSpore(int nutrientValue, Mushroom mushroom, Tecton location, String name) {
		super(nutrientValue, mushroom, location, name);
	}
	
	@Override
	public void accept(SporeVisitor visitor) {
	    visitor.visit(this);
	}
	
	/**
     * A spóra hatásának alkalmazása a megadott rovarra.
     * - Beállítja a rovar sebességét FAST-re
     * - Beállítja a begyűjtött tápanyagot.
     * - Elpusztítja a spórát.
     * 
     * @param insect A rovar, amelyre a spóra hatása alkalmazódik.
     */
	public void applyEffect(Insect insect) {
		insect.setSpeed(Insect.Speed.FAST);
		insect.setCollectedNutrients(nutrientValue);
		this.die();
	}
}

================
File: src/main/java/spore/GentleSpore.java
================
package main.java.spore;

import main.java.tecton.*;
import main.java.insect.Insect;
import main.java.mushroom.Mushroom;

/**
 * A GentleSpore osztály egy fonalvágást megtiltó hatású spórát reprezentál.
 */
public class GentleSpore extends Spore implements SporeAccept
{
	/**
     * Konstruktor, amely inicializálja a fonalvágást megtiltó spórát.
     * 
     * @param nutrientValue   A spóra által biztosított tápanyag értéke.
     * @param mushroom        A gomba, amelyből a spóra származik.
     * @param location        A Tecton, ahol a spóra található.
     * @param name            A spóra neve.
     */
	public GentleSpore(int nutrientValue, Mushroom mushroom, Tecton location, String name) {
		super(nutrientValue, mushroom, location, name);
	}
	
	@Override
	public void accept(SporeVisitor visitor) {
	    visitor.visit(this);
	}
	
	/**
     * A spóra hatásának alkalmazása a megadott rovarra.
     * - Kikapcsolja a fonalvágási képességet.
     * - Beállítja a begyűjtött tápanyagot.
     * - Elpusztítja a spórát.
     * 
     * @param insect A rovar, amelyre a spóra hatása alkalmazódik.
     */
	public void applyEffect(Insect insect) {
		insect.setCanCutString(false);
		insect.setCollectedNutrients(nutrientValue);
		this.die();
	}
}

================
File: src/main/java/spore/ParalyzerSpore.java
================
package main.java.spore;

import main.java.tecton.Tecton;
import main.java.insect.Insect;
import main.java.mushroom.Mushroom;

/**
 *A ParalyzerSpore osztály egy mozgást megtiltó hatású spórát reprezentál.
 */
public class ParalyzerSpore extends Spore implements SporeAccept {
	/**
     * Konstruktor, amely inicializálja a bénító spórát.
     * 
     * @param nutrientValue   A spóra által biztosított tápanyag értéke.
     * @param mushroom        A gomba, amelyből a spóra származik.
     * @param location        A Tecton, ahol a spóra található.
     * @param name            A spóra neve.
     */
	public ParalyzerSpore(int nutrientValue, Mushroom mushroom, Tecton location, String name) {
		super(nutrientValue, mushroom, location, name);
	}
	
	@Override
	public void accept(SporeVisitor visitor) {
	    visitor.visit(this);
	}
	
	/**
     * A spóra hatásának alkalmazása a megadott rovarra.
     * - Kikapcsolja a mozgási képességet.
     * - Beállítja a begyűjtött tápanyagot.
     * - Elpusztítja a spórát.
     * 
     * @param insect A rovar, amelyre a spóra hatása alkalmazódik.
     */
	public void applyEffect(Insect insect) {
		insect.setCanMove(false);
		insect.setCollectedNutrients(nutrientValue);
		this.die();
	}
}

================
File: src/main/java/spore/SlowSpore.java
================
package main.java.spore;

import main.java.tecton.Tecton;
import main.java.insect.Insect;
import main.java.mushroom.Mushroom;

/**
 * A SlowSpore osztály egy lassító hatású spórát reprezentál, amely egy rovarral 
 * történő találkozás esetén csökkenti annak sebességét.
 */
public class SlowSpore extends Spore implements SporeAccept {

	/**
     * Konstruktor, amely inicializálja a lassító spórát.
     * 
     * @param nutrientValue   A spóra által biztosított tápanyag értéke.
     * @param mushroom        A gomba, amelyből a spóra származik.
     * @param location        A Tecton, ahol a spóra található.
     * @param name            A spóra neve.
     */
	public SlowSpore(int nutrientValue, Mushroom mushroom, Tecton location, String name) {
		super(nutrientValue, mushroom, location, name);
	}
	
	@Override
	public void accept(SporeVisitor visitor) {
	    visitor.visit(this);
	}

	/**
     * A spóra hatásának alkalmazása a megadott rovarra.
     * - Beállítja a rovar sebességét SLOW-ra
     * - Beállítja a begyűjtött tápanyagot.
     * - Elpusztítja a spórát.
     * 
     * @param insect A rovar, amelyre a spóra hatása alkalmazódik.
     */
	public void applyEffect(Insect insect) {
		insect.setSpeed(Insect.Speed.SLOW);
		insect.setCollectedNutrients(nutrientValue);
		this.die();
	}
}

================
File: src/main/java/spore/SporeConsumptionVisitor.java
================
package main.java.spore;

import main.java.GameController;
import main.java.insect.AddInsectVisitor;
import main.java.insect.Insect;
import main.java.player.Player;
import main.java.player.PlayerAccept;

/**
 * Amikor egy Insect elfogyaszt egy Spore-t, ezt a visitert hívjuk,
 * így típusonként eltérő logikát tudunk futtatni.
 */
public class SporeConsumptionVisitor implements SporeVisitor {

    private final Insect insect;
    private final GameController gameController;

    public SporeConsumptionVisitor(Insect insect, GameController gameController) {
        this.insect = insect;
        this.gameController = gameController;
    }

    @Override
    public void visit(FastSpore s) {
        s.applyEffect(insect);
    }

    @Override
    public void visit(GentleSpore s) {
        s.applyEffect(insect);
    }

    @Override
    public void visit(SlowSpore s) {
        s.applyEffect(insect);
    }

    @Override
    public void visit(ParalyzerSpore s) {
        s.applyEffect(insect);
    }

    @Override
    public void visit(MultiplierSpore s) {
        // 1) az eredeti hatás
        s.applyEffect(insect);
        // 2) klónozás
        Insect clone = s.makeNewInsect(insect);
        gameController.getPlanet().getInsects().add(clone);
        AddInsectVisitor v = new AddInsectVisitor(insect, clone);
        for (Player player : gameController.getPlayers()) {
            ((PlayerAccept) player).accept(v);
        }
    }
}

================
File: src/main/java/tecton/TectonAccept.java
================
package main.java.tecton;

/**
 * A TectonAccept interfészt minden olyan osztálynak implementálnia kell,
 * amely elfogad egy TectonVisitor látogatót a Visitor tervezési minta szerint.
 * Ez lehetővé teszi, hogy különböző Tecton típusok viselkedése
 * bővíthető legyen anélkül, hogy módosítani kellene őket.
 */
public interface TectonAccept
{
	/**
     * Elfogad egy TectonVisitor látogatót, és meghívja rajta a megfelelő
     * visit metódust az aktuális objektum típusának megfelelően.
     *
     * @param visitor a látogató, amely műveletet hajt végre az objektumon
     */
	<R> R accept(TectonVisitor<R> visitor);
}

================
File: src/main/java/Updatable.java
================
package main.java;

/**
 * Egy olyan interfész, amelyet azok az osztályok valósítanak meg, 
 * amelyek állapota frissíthető a játék körének elején.
 */
public interface Updatable {

    /**
     * Frissíti az objektum állapotát.
     * A paraméter jelezheti, hogy véletlenszerűség is szerepet játsszon-e a frissítés során.
     * 
     * @param random - ha igaz, a frissítés véletlenszerű elemeket is tartalmazhat.
     */
    void update(boolean random);
}

================
File: src/.idea/misc.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectRootManager" version="2" default="true">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
</project>

================
File: src/.idea/vcs.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
  </component>
</project>

================
File: src/main/java/GameFileChooser.java
================
package main.java;

import main.java.player.Player;

import javax.swing.filechooser.FileFilter;
import javax.swing.*;
import java.io.*;
import java.util.ArrayList;

public class GameFileChooser {

    /**
     * Megjeleníti a fájlbetöltési dialógust és betölti a kiválasztott játékállást.
     *
     * @param parentComponent A szülő komponens, amihez a dialógus kapcsolódik
     * @param frame A JFrame, ahol a játék fut
     *
     * @return A betöltött játék controllere, vagy null ha a betöltés sikertelen
     */
    public static boolean loadGame(JFrame parentComponent, JFrame frame) {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Játékállás betöltése");
        fileChooser.setFileFilter(new FileFilter() {
            @Override
            public boolean accept(File f) {
                return f.isDirectory() || f.getName().toLowerCase().endsWith(".fung");
            }

            @Override
            public String getDescription() {
                return "Játékállapot fájlok (*.fung)";
            }
        });

        int result = fileChooser.showOpenDialog(parentComponent);
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            try {
                GameController loadedGame = loadGameFromFile(selectedFile, frame);
                if (loadedGame != null) {
                    System.out.println("Játékállapot sikeresen betöltve: " + selectedFile.getName());

                    // Új játékpanel létrehozása a betöltött játékkal
                    GamePanel gamePanel = new GamePanel(loadedGame.getPlayers());
                    gamePanel.setGameController(loadedGame);

                    // Frissítjük a framet
                    frame.getContentPane().removeAll();
                    frame.setJMenuBar(new GameMenu(frame, loadedGame));
                    frame.add(gamePanel);
                    frame.revalidate();
                    frame.repaint();
                    gamePanel.requestFocusInWindow();

                    return true;
                }
            } catch(Exception exc){
                    System.err.println("Hiba a játékállás betöltése közben: " + exc.getMessage());
                    JOptionPane.showMessageDialog(parentComponent, "Hiba a játékállás betöltése közben: " + exc.getMessage(), "Hiba", JOptionPane.ERROR_MESSAGE);
            }
        }
        return false;
    }

    /**
     * Megjeleníti a fájlmentési dialógust és elmenti a játékállást.
     *
     * @param parentComponent A szülő komponens, amihez a dialógus kapcsolódik
     * @param gameController A játékvezérlő, aminek az állapotát menteni szeretnénk
     * @return igaz, ha sikeres volt a mentés, egyébként hamis
     */
    public static boolean saveGame(JFrame parentComponent, GameController gameController) {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Játékállás mentése");
        fileChooser.setFileFilter(new FileFilter() {
            @Override
            public boolean accept(File f) {
                return f.isDirectory() || f.getName().toLowerCase().endsWith(".fung");
            }

            @Override
            public String getDescription() {
                return "Játékállás fájlok (*.fung)";
            }
        });

        int result = fileChooser.showSaveDialog(parentComponent);
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();

            // Biztosítjuk, hogy a fájl kiterjesztése .fung legyen
            String filePath = selectedFile.getAbsolutePath();
            if (!filePath.toLowerCase().endsWith(".fung")) {
                filePath += ".fung";
                selectedFile = new File(filePath);
            }

            // Megerősítés kérése, ha a fájl már létezik
            if (selectedFile.exists()) {
                int response = JOptionPane.showConfirmDialog(parentComponent,
                        "A fájl már létezik. Felülírja?",
                        "Megerősítés",
                        JOptionPane.YES_NO_OPTION,
                        JOptionPane.WARNING_MESSAGE);
                if (response != JOptionPane.YES_OPTION) {
                    return false;
                }
            }

            try {
                return saveGameToFile(gameController, selectedFile);
            } catch (Exception exc) {
                System.err.println("Hiba a játékállás mentése közben: " + exc.getMessage());
                JOptionPane.showMessageDialog(parentComponent, "Hiba a játékállás mentése közben: " + exc.getMessage(), "Hiba", JOptionPane.ERROR_MESSAGE);
                return false;
            }
        }
        return false;
    }

    /**
     * Menti a játék állapotát a megadott fájlba.
     *
     * @param gameController A játék kontroller
     * @param file A cél fájl
     * @return true, ha sikeres volt a mentés
     */
    private static boolean saveGameToFile(GameController gameController, File file) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file))) {
            // A játék állapotának mentése
            Planet planet = gameController.getPlanet();
            ArrayList<Player> players = gameController.getPlayers();
            int turnCounter = gameController.getTurnCounter();
            Player currentPlayer = gameController.getCurrentPlayer();
            boolean isInit = gameController.getInit();

            // Létrehozunk egy GameState objektumot, ami mindent tartalmaz
            GameState state = new GameState(planet, players, turnCounter, currentPlayer, isInit);
            oos.writeObject(state);

            System.out.println("Játékállás sikeresen elmentve: " + file.getName());
            return true;
        } catch (IOException e) {
            System.err.println("Hiba a játékállás mentése közben: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    /**
     * Betölti a játék állapotát a megadott fájlból.
     *
     * @param file A forrás fájl
     * @param frame A JFrame, ami a játékot tartalmazza (repaint callback számára)
     * @return A betöltött játék kontroller
     */
    private static GameController loadGameFromFile(File file, JFrame frame) {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) {
            // A játék állapotának betöltése
            GameState state = (GameState) ois.readObject();

            // Létrehozzuk az új GameController-t
            // A frame::repaint callback biztosítja, hogy a grafikus felület frissüljön
            GameController controller = new GameController(false, 20, frame::repaint);
            controller.setPlanet(state.planet());

            // Beállítjuk a játékosokat
            for (Player player : state.players()) {
                controller.addPlayer(player);
            }

            // Beállítjuk a kör számlálót és az aktuális játékost
            controller.setTurnCounter(state.turnCounter());
            controller.setCurrentPlayer(state.currentPlayer());
            controller.setInit(state.isInit());

            return controller;
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Hiba a játékállás betöltése közben: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
}

================
File: src/main/java/GameState.java
================
package main.java;

import main.java.player.Player;

import java.io.Serial;
import java.io.Serializable;
import java.util.ArrayList;

/**
 * A játék állapotát tároló osztály, a mentés/betöltés funkcióhoz.
 */
public record GameState(Planet planet, ArrayList<Player> players, int turnCounter, Player currentPlayer, boolean isInit) implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;

}

================
File: src/main/java/player/Player.java
================
package main.java.player;


import main.java.Nameable;
import main.java.Updatable;

/**
 * Az absztrakt Player osztály egy általános játékost reprezentál, amelynek van neve, pontszáma
 * és hátralévő akciói. Kétféle játékos származhat belőle: Shroomer és Insecter.
 */
public abstract class Player extends Nameable implements Updatable {

    public int score;
    public int remainingActions;

    /**
     * Létrehoz egy új játékost.
     *
     * @param name a játékos neve
     * @param testing ha true, akkor a játékos gyakorlatilag végtelen akcióval rendelkezik. Teszteléshez kell.
     */
     Player(String name, boolean testing) {
        setName(name);
        this.score = 0;
        update(testing);
    }
    
    /**
     * Visszaadja a játékos pontszámát.
     *
     * @return a játékos aktuális pontszáma
     */
    public int getScore() {
        return score;
    }

    /**
     * Beállítja a játékos pontszámát.
     *
     * @param score az új pontszám
     */
    public void setScore(int score) {
        this.score = score;
    }

    /**
     * Visszaadja a játékos hátralévő akcióinak számát.
     *
     * @return a hátralévő akciók száma
     */
    public int getActions() {
        return remainingActions;
    }

    /**
     * Beállítja a játékos hátralévő akcióinak számát.
     *
     * @param actions az új akciószám
     */
    public void setActions(int actions) {
        this.remainingActions = actions;
    }

    /**
     * Csökkenti a hátralévő akciók számát eggyel.
     */
    public void takeAction() {
        remainingActions--;
    }

    /**
     * Passzolja a játékos körét: az akciók száma nullára csökken.
     */
    public void pass() {
        remainingActions = 0;
    }
    
    /**
     * Az Updatable interfész felüldefiniált update függvénye. 
     * Visszaállítja a játékos akcióinak számát alapértelmezettre.
     *
     * @param testing A tesztelő állapot eldöntését meghatározó boolean.
     */
    public void update(boolean testing) {
    	if(!testing) {
        	setActions(3);
        }
        else {
        	setActions(10000);
        }
    }
}

================
File: src/main/java/tecton/BigTecton.java
================
package main.java.tecton;

import java.util.ArrayList;
import java.util.Random;

/**
 * BigTecton a Tecton egyik típusa, melyen 5 különböző fonal is lehet.
 * Implementálja a TectonAccept interfészt a visitor minta miatt.
 */
public class BigTecton extends Tecton implements TectonAccept  {

	 /**
     * Konstruktor – létrehoz egy új BigTecton példányt a megadott névvel és maximális gombafonal-számmal.
     *
     * @param maxStrings A maximálisan tárolható gombafonalak száma.
     */
    public BigTecton(int maxStrings) {
        super(maxStrings);
    }

    @Override
    public void createSplitTectons(ArrayList<Tecton> tectons, ArrayList<Tecton> newTectons) {
        createSplitTectonsWithFactory(() -> new BigTecton(getMaxStrings()), newTectons);
    }
    
    /**
     * Visitor minta accept metódusa: elfogadja a látogatót.
     *
     * @param visitor A látogatót reprezentáló objektum, amely végrehajtja a megfelelő műveletet.
     */
    @Override
    public <R> R accept(TectonVisitor<R> visitor) {
        return visitor.visit(this);
    }
}

================
File: src/main/java/tecton/CoarseTecton.java
================
package main.java.tecton;

import java.util.ArrayList;

/**
 * CoarseTecton a Tecton egyik típusa, melyen nem nőhet gombatest.
 * Implementálja a TectonAccept interfészt a visitor minta miatt.
 */
public class CoarseTecton extends Tecton implements TectonAccept {

    /**
     * Konstruktor: létrehoz egy új CoarseTecton példányt a megadott névvel és a maximális gombafonal számával, ami rajta lehet.
     *
     * @param maxStrings A maximálisan tárolható gombafonalak száma.
     */
    public CoarseTecton(int maxStrings) {
        super(maxStrings);
    }

    @Override
    public void createSplitTectons(ArrayList<Tecton> tectons, ArrayList<Tecton> newTectons) {
        createSplitTectonsWithFactory(() -> new CoarseTecton(getMaxStrings()), newTectons);
    }

    /**
     * Visitor minta accept metódusa: elfogadja a látogatót.
     *
     * @param visitor A látogatót reprezentáló objektum, amely végrehajtja a megfelelő műveletet.
     */
    @Override
    public <R> R accept(TectonVisitor<R> visitor) {
        return visitor.visit(this);
    }
}

================
File: src/main/java/tecton/GeometryTecton.java
================
package main.java.tecton;

import main.java.Geometry;

import java.io.Serial;
import java.io.Serializable;

public class GeometryTecton extends Geometry implements Serializable {
	@Serial
	private static final long serialVersionUID = 1L;
	private final int radius;
	
	public GeometryTecton(int x, int y, int radius) {
		super(x, y);
		this.radius = radius;
	}
	
    public int getRadius() {
		return radius;
	}
}

================
File: src/main/java/tecton/SmallTecton.java
================
package main.java.tecton;

import java.util.ArrayList;

/**
 * SmallTecton a Tecton egyik típusa, melyen csak 2 különböző fonal lehet.
 * Implementálja a TectonAccept interfészt a visitor minta miatt.
 */
public class SmallTecton extends Tecton implements TectonAccept {

	/**
     * Konstruktor: létrehoz egy új SmallTecton példányt a megadott névvel és a maximális gombafonal számával, ami rajta lehet.
     *
     * @param maxStrings A maximálisan tárolható gombafonalak száma.
     */
    public SmallTecton(int maxStrings) {
    	super(maxStrings);
    }

    @Override
    public void createSplitTectons(ArrayList<Tecton> tectons, ArrayList<Tecton> newTectons) {
        createSplitTectonsWithFactory(() -> new SmallTecton(getMaxStrings()), newTectons);
    }

    /**
     * Visitor minta accept metódusa: elfogadja a látogatót.
     */
	@Override
    public <R> R accept(TectonVisitor<R> visitor) {
        return visitor.visit(this);
    }
}

================
File: src/main/java/view/Drawable.java
================
package main.java.view;

public interface Drawable {

    public void drawItself();
    
}

================
File: src/main/java/GameOverVisitor.java
================
package main.java;

import main.java.player.*;

/**
 * A GameOverVisitor egy PlayerVisitor implementáció,
 * amely a játék végén meghatározza a legjobb játékosokat típusonként:
 * külön a legjobb Shroomer-t és a legjobb Insecter-t.
 * Az osztály a látogató minta alapján működik, és minden meglátogatott
 * játékostípust kiértékel az aktuális legjobbal összevetve.
 */
public class GameOverVisitor implements PlayerVisitor {

    private Shroomer bestShroomer = null;
    private Insecter bestInsecter = null;

    /**
     * Ha az adott shroomer jobb pontszámot ért el, mint az eddigi legjobb,
     * akkor lecseréli a bestShroomer értékét.
     *
     * @param shroomer a meglátogatott Shroomer típusú játékos
     */
    @Override
    public void visit(Shroomer shroomer) {
        if (bestShroomer == null || shroomer.getScore() > bestShroomer.getScore()){
            bestShroomer = shroomer;
        }
    }

    /**
     * Ha az adott insecter jobb pontszámot ért el, mint az eddigi legjobb,
     * akkor lecseréli a bestInsecter értékét.
     *
     * @param insecter a meglátogatott Shroomer típusú játékos
     */
    @Override
    public void visit(Insecter insecter){
        if (bestInsecter == null || insecter.getScore() > bestInsecter.getScore()) {
            bestInsecter = insecter;
        }
    }

    /**
     * Visszaadja a legjobb pontszámot elért Shroomer játékost.
     *
     * @return a legjobb Shroomer példány.
     */
    public Shroomer getBestShroomer() {
        return bestShroomer;
    }

    /**
     * Visszaadja a legjobb pontszámot elért Insecter játékost.
     *
     * @return a legjobb Insecter példány.
     */
    public Insecter getBestInsecter() {
        return bestInsecter;
    }
}

================
File: src/main/java/mushroom/Mushroom.java
================
package main.java.mushroom;

import java.util.ArrayList;

/**
 * A Mushroom osztály egy gombát reprezentál a játékban, amelyhez tartozik egy gombász (shroomer),
 * egy név, valamint lehet élő vagy halott állapotban.
 */
public class Mushroom {

	boolean dead;
	boolean testing;
	
	/**
     * Konstruktor, amely inicializál egy új Mushroom példányt.
     *
     * @param testing Tesztelési mód jelzője. Ha igaz, a gomba tesztelési üzemmódban jött létre.
     */
	public Mushroom(boolean testing) {
		dead = false;
		this.testing = testing;
	}

	public boolean getDead() {
		return dead;
	}
	
	/**
     * Meghívása esetén a gomba elpusztul: minden hozzá tartozó MushroomBody objektumot is elpusztít,
     * majd a saját állapotát halottra állítja.
     *
     * @param strings Az összes gombafonal listája.
     * @param bodies Az összes MushroomBody gombatest listája.
     */
	public void die(ArrayList<MushroomString> strings, ArrayList<MushroomBody> bodies) {
        for (MushroomBody body : bodies) {
            if (body.getMushroom() == this) {
                body.die(strings);
            }
        }
		dead = true;
	}
}

================
File: src/main/java/spore/MultiplierSpore.java
================
package main.java.spore;

import main.java.tecton.Tecton;
import main.java.insect.Insect;
import main.java.mushroom.Mushroom;

/**
 * A MultiplierSpore egy olyan spóra, amely nemcsak tápanyagot ad a rovarnak, 
 * hanem klónozza is azt – egy új rovar jön létre ugyanazon a helyen, módosított névvel.
 */
public class MultiplierSpore extends Spore implements SporeAccept {
	/**
     * Konstruktor, amely inicializálja a sokszorozó spórát.
     * 
     * @param nutrientValue   A spóra által biztosított tápanyag értéke.
     * @param mushroom        A gomba, amelyből a spóra származik.
     * @param location        A Tecton, ahol a spóra található.
     * @param name            A spóra neve.
     */
    public MultiplierSpore(int nutrientValue, Mushroom mushroom, Tecton location, String name) {
        super(nutrientValue, mushroom, location, name);
    }
    
    @Override
    public void accept(SporeVisitor visitor) {
        visitor.visit(this);
    }
    
    /**
     * A spóra hatásának alkalmazása a megadott rovarra.
     * - Beállítja a begyűjtött tápanyagot.
     * - Elpusztítja a spórát.
     * 
     * @param insect A rovar, amelyre a spóra hatása alkalmazódik.
     */
    public void applyEffect(Insect insect) {
        insect.setCollectedNutrients(nutrientValue);
        this.die();
    }
    
    /**
     * Egy új rovar létrehozása a meglévő alapján.
     * A klón ugyanott, és "_clone" utótaggal ellátott névvel jelenik meg.
     * Ez a metódus meghívja az `applyEffect()` függvényt is az eredeti rovaron.
     * 
     * @param insect Az eredeti rovar
     * @return Az új, klónozott rovar
     */
    public Insect makeNewInsect(Insect insect) {
        Tecton location = insect.getLocation();
        return new Insect(location);
    }
}

================
File: src/main/java/tecton/HealingTecton.java
================
package main.java.tecton;

import java.util.ArrayList;

/**
 * HealingTecton a Tecton egyik típusa, melyen a fonalak nem halnak el.
 * Implementálja a TectonAccept interfészt a visitor minta miatt.
 */
public class HealingTecton extends Tecton implements TectonAccept {
	
	/**
     * Konstruktor: létrehoz egy új HealingTecton példányt a megadott névvel és a maximális gombafonal számával, ami rajta lehet.
     *
     * @param maxStrings A maximálisan tárolható gombafonalak száma.
     */
    public HealingTecton(int maxStrings) {
    	super(maxStrings);
    }

    @Override
    public void createSplitTectons(ArrayList<Tecton> tectons, ArrayList<Tecton> newTectons) {
        createSplitTectonsWithFactory(() -> new HealingTecton(getMaxStrings()), newTectons);
    }
    /**
     * Visitor minta accept metódusa: elfogadja a látogatót.
     *
     * @param visitor A látogatót reprezentáló objektum, amely végrehajtja a megfelelő műveletet.
     */
	@Override
    public <R> R accept(TectonVisitor<R> visitor) {
        return visitor.visit(this);
    }
}

================
File: src/main/java/tecton/ToxicTecton.java
================
package main.java.tecton;

import java.util.ArrayList;

/**
 * ToxicTecton a Tecton egyik típusa, melyen a gombák egy idő után elpusztulnak.
 * Implementálja a TectonAccept interfészt a visitor minta miatt.
 */
public class ToxicTecton extends Tecton implements TectonAccept {

	/**
     * Konstruktor: létrehoz egy új ToxicTecton példányt a megadott névvel és a maximális gombafonal számával, ami rajta lehet.
     *
     * @param maxStrings A maximálisan tárolható gombafonalak száma.
     */
    public ToxicTecton(int maxStrings) {
    	super(maxStrings);
    }

    @Override
    public void createSplitTectons(ArrayList<Tecton> tectons, ArrayList<Tecton> newTectons) {
        createSplitTectonsWithFactory(() -> new ToxicTecton(getMaxStrings()), newTectons);
    }
    /**
     * Visitor minta accept metódusa: elfogadja a látogatót.
     *
     * @param visitor A látogatót reprezentáló objektum, amely végrehajtja a megfelelő műveletet.
     */
	@Override
    public <R> R accept(TectonVisitor<R> visitor) {
        return visitor.visit(this);
    }
}

================
File: src/main/java/view/DefaultDrawingFactory.java
================
package main.java.view;

public class DefaultDrawingFactory implements DrawingFactory {

    @Override
    public DefaultTectonDrawer createTectonDrawer(){
        return new DefaultTectonDrawer();
    }

    @Override
    public DefaultSporeDrawer createSporeDrawer(){
        return new DefaultSporeDrawer();
    }

    @Override
    public DefaultMushroomBodyDrawer createMushroomBodyDrawer(){
        return new DefaultMushroomBodyDrawer();
    }

    @Override
    public DefaultMushroomStringDrawer createMushroomStringDrawer(){
        return new DefaultMushroomStringDrawer();
    }

    @Override
    public DefaultInsectDrawer createInsectDrawer(){
        return new DefaultInsectDrawer();
    }

}

================
File: src/main/java/view/DrawingFactory.java
================
package main.java.view;

public interface DrawingFactory {
    DefaultTectonDrawer createTectonDrawer();
    DefaultSporeDrawer createSporeDrawer();
    DefaultMushroomBodyDrawer createMushroomBodyDrawer();
    DefaultMushroomStringDrawer createMushroomStringDrawer();
    DefaultInsectDrawer createInsectDrawer();
}

================
File: src/main/java/view/UtilityTool.java
================
package main.java.view;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Objects;

public class UtilityTool {

    public BufferedImage load(String path){
        BufferedImage bufim = null;
        try {
            bufim = ImageIO.read(Objects.requireNonNull(getClass().getClassLoader().getResourceAsStream(path)));
        } catch (IOException e) {
            System.out.println("[UTILITYTOOL] ERROR: " + e.getMessage());
        } catch (NullPointerException e) {
            System.out.println("[UTILITYTOOL] ERROR: File not found at path: " + path);
        }
        return bufim;
    }

}

================
File: src/main/java/player/Insecter.java
================
package main.java.player;

import main.java.insect.Insect;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;


/**
 * Az Insecter osztály a játékos egy fajtáját reprezentálja,
 * aki rovarokat irányít a játék során.
 */
public class Insecter extends Player implements PlayerAccept, Serializable {

    List<Insect> insects;

    /**
     * Létrehoz egy új {@code Insecter} játékost a megadott névvel és akciókorlátozással.
     *
     * @param name a játékos neve
     * @param infinite ha true, akkor a játékosnak gyakorlatilag végtelen akciója van. Teszteléshez szükséges.
     */
    public Insecter(String name, boolean infinite) {
        super(name, infinite);
        insects = new ArrayList<>();
    }

    /**
     * Visszaadja a játékos által irányított rovarok listáját.
     *
     * @return a rovarok listája
     */
    public List<Insect> getInsects() {
        return insects;
    }
    
    /**
     * Hozzáad egy rovart a játékos által irányított rovarokhoz.
     *
     * @param i a hozzáadandó rovar
     */
    public void addInsect(Insect i) {
    	insects.add(i);
    }
    
    /**
     * Beállítja a játékos által irányított rovarok listáját.
     *
     * @param insects az új rovarlista
     */
    public void setInsects(List<Insect> insects) {
        this.insects = insects;
    }
    
    /**
     * Meghívja a látogatót a Visitor tervezési minta alapján.
     *
     * @param visitor a látogató objektum
     */
    @Override
    public void accept(PlayerVisitor visitor) {
    	visitor.visit(this);
    }
}

================
File: src/main/java/player/Shroomer.java
================
package main.java.player;

import main.java.mushroom.Mushroom;

import java.io.Serializable;

/**
 * A Shroomer osztály egy játékos típust reprezentál, amely egyetlen
 * Mushroom entitás felett rendelkezik.
 * A Shroomer meghatározott parancsokat hajthat végre, mint például:
 * GrowHypha, MushroomBody, SpreadSpore, valamint Pass.
 */
public class Shroomer extends Player implements PlayerAccept, Serializable {

    Mushroom mushroom;

    /**
     * Egy új Shroomer példányt hoz létre megadott névvel, gombával és akciószámmal.
	 *
     * @param name     a játékos neve.
     * @param infinite ha true, akkor végtelen számú akcióval rendelkezik. Teszteléshez szükséges.
     */
    public Shroomer(String name, boolean infinite, Mushroom mushroom) {
        super(name, infinite);
        this.mushroom = mushroom;
    }
    
    /**
     * Visszaadja a játékoshoz tartozó Mushroom példányt.
     *
     * @return a játékos gombája.
     */
    public Mushroom getMushroom() {
        return mushroom;
    }

    /**
     * Beállítja a játékoshoz tartozó gombát.
     *
     * @param mushroom az új Mushroom példány
     */
    public void setMushroom(Mushroom mushroom) {
        this.mushroom = mushroom;
    }

    /**
     * Elfogadja a látogatót a Visitor minta szerint.
     *
     * @param visitor a PlayerVisitor példány, amely meglátogatja ezt a játékost
     */
    @Override
    public void accept(PlayerVisitor visitor) {
    	if(mushroom != null) {
            visitor.visit(this);
        }
    }
}

================
File: src/main/java/spore/Spore.java
================
package main.java.spore;

import main.java.Geometry;
import main.java.Nameable;
import main.java.tecton.Tecton;
import main.java.insect.Insect;
import main.java.mushroom.Mushroom;

import java.io.Serializable;
import java.util.Random;

/**
 * Az absztrakt Spore osztály egy általános spóra entitást reprezentál,
 * amely rendelkezik tápértékkel, elhelyezkedéssel, szülő gombával és "élet" státusszal.
 * Konkrét hatását az örökölt osztályok valósítják meg.
 */
public abstract class Spore extends Nameable implements Serializable {

    protected int nutrientValue;     // A spóra által biztosított tápanyagmennyiség
    protected Mushroom mushroom;     // A gomba, amelyből a spóra származik
    protected Tecton location;       // A spóra jelenlegi elhelyezkedése a játéktéren
    protected boolean dead;          // A spóra él-e (false) vagy már elpusztult (true)
    protected Geometry geometry;

    /**
     * Konstruktor a Spore példány létrehozására.
     * 
     * @param nutrientValue   A spóra által biztosított tápanyag értéke.
     * @param mushroom        A gomba, amelyből a spóra származik.
     * @param location        A Tecton, ahol a spóra található.
     * @param name            A spóra neve.
     */
    public Spore(int nutrientValue, Mushroom mushroom, Tecton location, String name) {
        this.nutrientValue = nutrientValue;
        this.mushroom = mushroom;
        this.location = location;
        setName(name);
        this.dead = false;
    }

    /**
     * Generál a spóra számára egy véletlen tápértéket.
     */
    public static int randomNutrientValue() {
        Random rand = new Random();
        int result = rand.nextInt(3);
        return ++result;
    }

    //Getterek, Setterek

    public Tecton getLocation() {
        return location;
    }

    public Mushroom getMushroom() {
        return mushroom;
    }

    public boolean getDead() {
        return dead;
    }
    
    public Geometry getGeometry() {
    	return geometry;
    }
    
    public void setGeometry(Geometry geometry) {
    	this.geometry = geometry;
    }

    /**
     * Megjelöli a spórát elpusztultként.
     */
    public void die() {
        dead = true;
    }

    /**
     * A spóra hatásának alkalmazása egy rovarra.
     * Ezt a konkrét spóra típusok valósítják meg.
     * 
     * @param insect Az érintett rovar
     */
    public abstract void applyEffect(Insect insect);
}

================
File: src/main/java/view/SporeDrawer.java
================
package main.java.view;

import main.java.spore.Spore;
import java.awt.*;

public interface SporeDrawer {
    void draw(Graphics2D g2, Spore s);
}

================
File: src/main/java/mushroom/GeometryString.java
================
package main.java.mushroom;

import main.java.Geometry;

import java.io.Serial;
import java.io.Serializable;

public class GeometryString extends Geometry implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;
    private final int x2;
    private final int y2;

    public GeometryString(int x, int y, int x2, int y2) {
        super(x,y);
        this.x2 = x2;
        this.y2 = y2;
    }

    public int getX2() {
        return x2;
    }

    public int getY2() {
        return y2;
    }

}

================
File: src/main/java/mushroom/MushroomBody.java
================
package main.java.mushroom;

import main.java.Geometry;
import main.java.Updatable;
import main.java.tecton.*;
import main.java.spore.*;
import main.java.player.Shroomer;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Random;

/**
 * A MushroomBody osztály a gombatest viselkedését modellezi, beleértve a spórák terjesztését, 
 * a növekedést és a halált. Ezen kívül kezeli a gomba elhelyezkedését és annak állapotát.
 */
public class MushroomBody implements Updatable, Serializable {
	private final Tecton location;
	private final Mushroom mushroom;
	private int remainingSporulations;
	private boolean availableSpores;
	private int state;
	boolean dead;
	boolean testing;
	private Geometry geometry;
	
	/**
     * Konstruktor, amely inicializálja a gombatest helyét, gombáját, állapotát, nevét, és tesztelési állapotát.
     *
     * @param location A gombatest tektonja, amin elhelyezkedik.
     * @param mushroom A gomba, amelyhez a gombatest tartozik.
     * @param state A gombatest állapota (0 - Kicsi, 1 - Közepes, 2 - Kifejlett).
     * @param testing Tesztelési jelző.
     */
	public MushroomBody(Tecton location, Mushroom mushroom, int state, boolean testing) { //ctor
		this.location = location;
		this.mushroom = mushroom;
		if(state == 2) {
			availableSpores = true;
		}
		else {
			availableSpores = testing;
		}
		this.testing = testing;
		this.state = state;
		remainingSporulations = 3;
		dead = false;
	}

	//Getterek
	public Tecton getLocation() {
		return location;
	}

	public int getRemainingSporulation() {
		return remainingSporulations;
	}

	public Mushroom getMushroom() {
		return mushroom;
	}

	public boolean getDead() {
		return dead;
	}
		
	public Geometry getGeometry() {
		return geometry;
	}
		
	public void setGeometry(Geometry geometry) {
		this.geometry = geometry;
	}
	
	/**
     * Az Updatable interfész felüldefiniált update függvénye. 
     * Elvégzi a gomba növekedését, és a spórák termelését.
     *
     * @param random A véletlenséget be/kikapcsoló változó.
     */
	public void update(boolean random){
		if(random){
			Random rng = new Random();
			int n = rng.nextInt(3);
			System.out.println("generált gombatest növekvős szám: " + n);
			if(n == 0)
				grow();
			n = rng.nextInt(4);
			System.out.println("generált spóratermelős szám: " + n);
			if(n == 0)
				produceSpores();
		}
		else
			grow();
	}
	
	/**
     * Spóra termelését végzi el, ha van elérhető spóra.
     * Csökkenti a hátralévő spóratermelések számát.
     */
	public void produceSpores() {
		availableSpores = true;
	}
	
	/**
     * Megvizsgálja, hogy a cél tekton elég közel van-e a gombatesthez.
     *
     * @param target A cél tekton.
     * @return true, ha a cél tekton elég közel van, false egyébként.
     */
	private boolean isTargetInRange(Tecton target) {
		 ArrayList<Tecton> neighbours;
		 neighbours = location.getNeighbours();
		 if (state == 1) {
			 return neighbours.contains(target);
		 }
		 if (state == 2) {
		    for (Tecton neighbour : neighbours) {
		    	if (neighbour == target || neighbour.getNeighbours().contains(target))
		            return true;
		    }
		 }
		 return false;
	}
	
	/**
     * Létrehoz egy véletlenszerű spórát a megadott cél tektonra.
     *
     * @param target A cél tekton.
     * @param newName Az új spóra neve.
     * @return A létrehozott spóra.
     */
	private Spore createRandomSpore(Tecton target, String newName) {
	    Random rand = new Random();
	    int type = rand.nextInt(5);
		Spore spore;
        switch (type) {
			case 0 :
				spore = new FastSpore(Spore.randomNutrientValue(), mushroom, target, newName);
				break;
			case 1 :
				spore = new SlowSpore(Spore.randomNutrientValue(), mushroom, target, newName);
				break;
			case 2 :
				spore = new GentleSpore(Spore.randomNutrientValue(), mushroom, target, newName);
				break;
			case 3 :
				spore = new ParalyzerSpore(Spore.randomNutrientValue(), mushroom, target, newName);
				break;
			case 4 :
				spore = new MultiplierSpore(Spore.randomNutrientValue(), mushroom, target, newName);
				break;
			default :
				spore = new FastSpore(Spore.randomNutrientValue(), mushroom, target, newName);
				break;
		};
		return spore;
    }
	
	/**
     * Létrehoz egy konkrét típusú spórát a megadott cél tektonra, csak teszteléshez.
     *
     * @param target A cél tekton.
     * @param newName Az új spóra neve.
     * @param type A spóra típusa.
     * @return A létrehozott spóra.
     */
	private Spore createExactSpore(Tecton target, String newName, String type) {
		Spore spore;
        switch (type) {
            case "Fast" :
			case "fast" : {
				spore = new FastSpore(1, mushroom, target, newName);
				break;
			}
			case "Slow" : 
			case "slow" : { 
				spore = new SlowSpore(2, mushroom, target, newName);
				break;
			}
			case "Gentle" : 
			case "gentle" : { 
				spore = new GentleSpore(2, mushroom, target, newName);
				break;
			}
			case "Paralyzer" : 
			case "paralyzer" : { 
				spore = new ParalyzerSpore(2, mushroom, target, newName);
				break;
			}
			case "Multiplier" : 
			case "multiplier" : { 
				spore = new MultiplierSpore(2, mushroom, target, newName);
				break;
            }
			default : {
                System.out.println("A megadott típus érvénytelen, egy alap gyorsító spórát hozok létre");
                spore = new FastSpore(1, mushroom, target, newName);
				break;
            }
        }
		return spore;
	}
	
	/**
     * Spórát helyez el a megadott cél tektonon.
     * Megvizsgálja, hogy a cél tekton a megfelelő távolságra van-e, és hogy van-e elérhető spóra.
     *
     * @param target A cél tekton.
     * @param newName Az új spóra neve.
     * @param type A spóra típusa.
     */
	public Spore spreadSpores(Tecton target, String newName, String type) {
		Spore sp;
		if (!isTargetInRange(target)) return null;
		if(!availableSpores) return null;
		if(!testing) sp = createRandomSpore(target, newName);
		else sp = createExactSpore(target, newName, type);
		availableSpores = false;	
		remainingSporulations--;
		return sp;
	}
	
	/**
     * Növeszti a gombát, ha a gombatest állapota még nem kifejlett.
     */
	void grow() {
		if(state != 2) {
			state++;
		}
	}
	
	/**
     * Megvizsgálja, hogy van-e elég spóra az adott tektonon egy gombatest növesztéséhez.
     *
     * @param spores Az összes spóra listája.
     * @param tecton A tekton, amit vizsgálunk.
     * @return true, ha van elég spóra, false egyébként.
     */
	public boolean hasEnoughSpores(ArrayList<Spore> spores, Tecton tecton) {
		int counter = 0;
        for (Spore spore : spores) {
			if (spore.getLocation() == tecton) {
				counter++;
			}
		}
        return counter > 2;
	}
	
	/**
     * Megvizsgálja, hogy tektonon teljesül-e minden feltétel egy gombatest növesztéséhez.
     *
     * @param tecton A tekton, amit vizsgálunk.
     * @param spores Az összes spóra listája.
     * @param bodies Az összes gombatest.
     * @param strings Az összes gombafonal listája.
     * @return true, ha van elég spóra, false egyébként.
     */
	private boolean validTarget(Tecton tecton, ArrayList<Spore> spores, ArrayList<MushroomBody> bodies, ArrayList<MushroomString> strings) {
		CanGrowBodyVisitor v = new CanGrowBodyVisitor();
		TectonAccept acceptor = (TectonAccept) tecton;
		acceptor.accept(v);
		for (MushroomBody body : bodies) {
			if (body.getLocation() == tecton) {
				return false;
			}
		}
		boolean hasString = false;
		for (MushroomString string : strings) {
            if (string.getConnection().contains(tecton)) {
                hasString = true;
                break;
            }
		}
		//hasString = true;
        return hasEnoughSpores(spores, tecton) && v.canPerformAction() && hasString;
    }
	
	/**
     * Egy új gombatest kinövését megvalósító függvény.
     *
     * @param spores Az összes spóra listája.
     * @param tecton A tekton, amelyen kinő.
     */
	public MushroomBody giveBirth(ArrayList<Spore> spores, Tecton tecton, ArrayList<MushroomBody> bodies, ArrayList<MushroomString> strings, Shroomer shroomer) {
		if(!validTarget(tecton, spores, bodies, strings))
			return null;
		
		tecton.markBodyGrown();
        for (Spore spore : spores)
            if (spore.getLocation() == tecton) spore.die();
        shroomer.score++;
        return new MushroomBody(tecton, this.mushroom, 0, false);
	}
	
	public String getState() {
		if(state == 0) {
			return "SMALL";
		}
		else if(state == 1) {
			return "MEDIUM";
		}
		else {
			return "BIG";
		}
	}
	
	/**
     * A gombatest halálát végrehajtó metódus, amely meghívja az összes kapcsolódó fonal halálát is.
     *S
     * @param strings A gombafonalak listája.
     */
	public void die(ArrayList<MushroomString> strings) {
		for(int i = 0; i < strings.size(); i++) {
			if (strings.get(i).getNeighbours().get(0) == null) {
				strings.get(i).die(strings);
			}
		}
		dead = true;
	}
}

================
File: src/main/java/tecton/TectonDrawerVisitor.java
================
package main.java.tecton;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

import main.java.MainMenu;
import main.java.view.UtilityTool;

public class TectonDrawerVisitor implements TectonVisitor<Void> {

	private final Graphics2D g2;
	UtilityTool uTool = new UtilityTool();

	public TectonDrawerVisitor(Graphics2D g2) {
		this.g2 = g2;
	}

	public Void visit(BigTecton big) {
		BufferedImage image = uTool.load(MainMenu.prefix + "bt.png");
		float r = big.getGeometry().getRadius();
		g2.drawImage(image, (int) (big.getGeometry().getX() - r),
				(int) (big.getGeometry().getY() - r),
				(int)r * 2, (int)r * 2, null);
		return null;
	}

	public Void visit(SmallTecton small) {
		BufferedImage image = uTool.load(MainMenu.prefix + "st.png");
		float r = small.getGeometry().getRadius();
		g2.drawImage(image, (int) (small.getGeometry().getX() - r),
                (int) (small.getGeometry().getY() - r),
                (int) (r * 2), (int) (r * 2), null);

		return null;
	}


	public Void visit(ToxicTecton toxic) {
		BufferedImage image = uTool.load(MainMenu.prefix + "tt.png");
		float r = toxic.getGeometry().getRadius();
		g2.drawImage(image, (int) (toxic.getGeometry().getX() - r),
                (int) (toxic.getGeometry().getY() - r),
                (int) (r * 2), (int) (r * 2), null);

		return null;
	}

	public Void visit(HealingTecton healing) {
		BufferedImage image = uTool.load(MainMenu.prefix + "ht.png");
		float r = healing.getGeometry().getRadius();
		g2.drawImage(image, (int) (healing.getGeometry().getX() - r),
                (int) (healing.getGeometry().getY() - r),
                (int) (r * 2), (int) (r * 2), null);

		return null;
	}

	public Void visit(CoarseTecton coarse) {
		BufferedImage image = uTool.load(MainMenu.prefix + "ct.png");
		float r = coarse.getGeometry().getRadius();
		g2.drawImage(image, (int) (coarse.getGeometry().getX() - r),
                (int) (coarse.getGeometry().getY() - r),
                (int) (r * 2), (int) (r * 2), null);

		return null;
	}
}

================
File: src/main/java/view/DefaultMushroomStringDrawer.java
================
package main.java.view;

import java.awt.*;
import main.java.mushroom.*;

public class DefaultMushroomStringDrawer implements MushroomStringDrawer {

    @Override
    public void draw(Graphics2D g2, MushroomString ms) {

        Stroke originalStroke = g2.getStroke();

        if(ms.getDead()){
            g2.setColor(Color.GRAY);
        } else if(ms.getLifeCycle() == MushroomString.LifeCycle.Child) {
            g2.setColor(Color.GREEN);
        } else {
            g2.setColor(Color.BLUE);
        }

        float thickness = ms.getLifeCycle() == MushroomString.LifeCycle.Grown ? 3.0f : 1.5f;
        g2.setStroke(new BasicStroke(thickness));
        g2.drawLine(ms.getGeometry().getX(), ms.getGeometry().getY(),
                ms.getGeometry().getX2(), ms.getGeometry().getY2());
        g2.setStroke(originalStroke);
    }
}

================
File: src/main/java/view/DefaultTectonDrawer.java
================
package main.java.view;

import java.awt.*;
import main.java.tecton.*;

public class DefaultTectonDrawer extends UtilityTool implements TectonDrawer {


    public DefaultTectonDrawer() {}

    @Override
    public void draw(Graphics2D g2, Tecton tecton){
    	TectonAccept acceptor = (TectonAccept) tecton;
    	TectonDrawerVisitor tdvisitor = new TectonDrawerVisitor(g2);
    	acceptor.accept(tdvisitor);
    }
}

================
File: src/main/java/view/InsectDrawer.java
================
package main.java.view;

import java.awt.*;
import main.java.insect.Insect;

public interface InsectDrawer {
    void draw(Graphics2D g2, Insect i);
}

================
File: src/main/java/view/MushroomBodyDrawer.java
================
package main.java.view;

import java.awt.*;
import main.java.mushroom.MushroomBody;

public interface MushroomBodyDrawer {
    void draw(Graphics2D g2, MushroomBody mb);
}

================
File: src/main/java/view/MushroomStringDrawer.java
================
package main.java.view;

import java.awt.*;
import main.java.mushroom.MushroomString;

public interface MushroomStringDrawer {
    void draw(Graphics2D g2, MushroomString ms);
}

================
File: src/main/java/view/TectonDrawer.java
================
package main.java.view;

import main.java.tecton.Tecton;
import java.awt.*;

public interface TectonDrawer {
    void draw(Graphics2D g2, Tecton t);
}

================
File: src/main/java/Geometry.java
================
package main.java;


import java.io.Serial;
import java.io.Serializable;

public class Geometry implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;
    private final int x;
    private final int y;


    public Geometry(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // getterek, ha kellenek a DrawManagernek
    public int getX() { return x; }
    public int getY() { return y; }
}

================
File: src/main/java/mushroom/MushroomString.java
================
package main.java.mushroom;

import java.io.Serializable;
import java.util.ArrayList;
import main.java.Nameable;
import main.java.Updatable;

import main.java.tecton.*;

/**
 * A gombafonalat megvalósító osztály, melynek tulajdonsága az általa összekötött két tekton, a hozzá kapcsolódó
 * fonalak, a gombája, érettségi szintje, és az állapota, hogy életben van-e, vagy már elpusztult
 */
public class MushroomString extends Nameable implements Updatable, Serializable {
	
	private static class CloneCounter {
	    private static int counter = 1;
	    static synchronized int next() { return counter++; }
	}
	
	private final ArrayList<Tecton> connection;
	private final ArrayList<MushroomString> neighbours;
	private final Mushroom mushroom;
	private static final int TOXIC_AGE_LIMIT = 3; // 3 kör után elpusztul a toxic tektonon

	public enum LifeCycle {Child, Grown}
	private LifeCycle lifeCycle = LifeCycle.Child;
	
	private boolean connectedToBody = false;
	boolean dead;
	int lifeLine;
	int age = 0;
	
	private int orphanAge = 0;                // hány kör óta árva?
	private static final int ORPHAN_AGE_LIMIT = 3;

	GeometryString geometry;

	/**
	 * A MushroomString osztály konstruktora, amely inicializálja a fonal nevét, a hozzá tartozó gombát, 
	 * a kapcsolódó tektonokat és a szomszédos fonalakat.
	 * 
	 * @param name A fonal neve.
	 * @param mushroom A gomba, amelyhez a fonal tartozik.
	 * @param connection A tektonok listája, amelyekhez a fonal csatlakozik.
	 * @param neighbours A szomszédos fonalak listája, amelyek a fonal szomszédai.
	 * @param lifeLine A születésének aktuális körszáma
	 */
	public MushroomString(String name, Mushroom mushroom, ArrayList<Tecton> connection, ArrayList<MushroomString> neighbours, int lifeLine, GeometryString geometry) {
		this.mushroom = mushroom;
		this.connection = connection;
		this.neighbours  = (neighbours == null)
                ? new ArrayList<>(java.util.Arrays.asList(null, null))
                : neighbours;   
		dead = false;
		setName(name);
		this.lifeLine = lifeLine;
		this.geometry = geometry;
	}
	
	public static String nextCloneName(String base) {
	    return base + "_clone" + CloneCounter.next();
	}
	
	//Getterek, Setterek
	public Mushroom getMushroom() {
		return mushroom;
	}

	public ArrayList<MushroomString> getNeighbours() {
		return neighbours;
	}

	public ArrayList<Tecton> getConnection() {
		return connection;
	}

	public boolean getDead() {
		return dead;
	}

	public int getLifeLine() {
		return lifeLine;
	}
	
	public LifeCycle getLifeCycle() {
		return lifeCycle;
	}
	
	public boolean isConnectedToBody() {
	    return connectedToBody;
	}

	public void setConnectedToBody(boolean b) {
	    connectedToBody = b;
	}

	
	/**
	 * Megnöveli a fonal aktuális "életszámlálóját" 1-gyel
	 */
	public void incrementAge() {
		lifeLine++;
		age++;
	}
	
	/**
	 * A fonal terjedését megvalósító függvény.
	 * Elvégzi a szükséges feltételek ellenőrzését, majd hozzáadja az étvett tektont a connections-höz,
	 * illetve megkeresi, hogy van-e egy másik fonal, amihez ez az új csatlakozni tud
	**/
	
	public boolean branch(Tecton target, ArrayList<MushroomString> allStrings) {
	    // Nem tudunk nőni, ha:
	    if (dead || !connection.get(0).getNeighbours().contains(target)) {
			return false;
		}
	    /* ------------------------------------------------------------------
	     * B) Már összeköt két Tectont → új fonalat kell létrehozni,
	     *    amely a második Tectonról (connection.get(1)) indul tovább.
	     * ------------------------------------------------------------------ */
	    Tecton start = connection.get(1);          // a „híd” másik vége
	    ArrayList<Tecton> newConn = new ArrayList<>();
	    newConn.add(start);
	    newConn.add(target);

	    ArrayList<MushroomString> newNb = new ArrayList<>();
	    newNb.add(this);         // az 1. szomszéd az „anyafonal”
	    newNb.add(null);

	    MushroomString child = new MushroomString(
	    		getName() + "_clone" + CloneCounter.next(), // valami egyedi név
	            mushroom,
	            newConn,
	            newNb,
	            lifeLine,// a körszámot örökli
				new GeometryString(this.getGeometry().getX2(), this.getGeometry().getY2(), target.getGeometry().getX(),target.getGeometry().getY()) // új geometria
	    );

	    /* A régi fonal egyik szomszédjaként bejegyezzük az újat            */
		neighbours.set(1, child);
	    allStrings.add(child);
	    return true;
	}

	private boolean hasHealingEnd(){
		boolean hasHealingEnd = false;
		for (Tecton t : connection) {
			KeepStringAliveVisitor healV = new KeepStringAliveVisitor();
			((TectonAccept) t).accept(healV);
			if (healV.canPerformAction()) {      // Healing -> true
				hasHealingEnd = true;
				break;
			}
		}
		return hasHealingEnd;
	}

	private void removeOrphans() {
		connection.removeIf(t -> {
			KeepStringAliveVisitor healV = new KeepStringAliveVisitor();
			((TectonAccept) t).accept(healV);
			return !healV.canPerformAction();      // true -> nem Healing, leesik
		});

		if (connection.isEmpty()) {                // csak akkor hal meg, ha SEMMI nem maradt
			dead = true;
			return;
		}
		orphanAge = 0;                             // számláló újraindul
	}
	
	/**
     * Az Updatable interfész felüldefiniált update függvénye. 
     * Elvégzi a fonal fejlődését, és ha még nem halott, akkor megnöveli a lifeLine-t.
     *
     * @param random A véletlenséget be/kikapcsoló változó.
     */
	@Override
	public void update(boolean random) {
		/* 1) öregszünk */
		if (!dead) {
			incrementAge();
		}

		/* 2) végignézzük, van-e toxikus Tecton */
		boolean toxicReachedLimit = false;

		CanKillStringVisitor v = new CanKillStringVisitor();
		for (Tecton t : new ArrayList<>(connection)) {       // biztonság kedvéért másolaton iterálunk
			((TectonAccept) t).accept(v);

			/* csak ToxicTectonra ad true-t a visitor */
			if (v.canPerformAction() && age >= TOXIC_AGE_LIMIT) {
				toxicReachedLimit = true;
				connection.remove(t);        // ez a Tecton „leesik” a fonalról
			}
		}

		/* 3) ha minden ág leesett, tényleg meghalunk */
		if (toxicReachedLimit && connection.isEmpty()) {
			dead = true;
			return;
		}
	    
	    /*  if a fonal már nem kapcsolódik a gombatesthez ÉS nem Healing-en áll,
	    akkor öregszik s végül elpusztul  */
		if (!connectedToBody) {
			v = new CanKillStringVisitor();
			((TectonAccept) connection.get(0)).accept(v);

			if (v.canPerformAction() && age >= TOXIC_AGE_LIMIT) {
				dead = true;
				return;
			}
		}

	    /* 4) ha már nincs toxikus águnk, indulunk elölről a számlálással,
	          különben a maradék ág is feleslegesen tovább öregedne */
		if (toxicReachedLimit) {
			age = 0;
		}

		/* 4/b) – árva-e?  (nincs gyökér-kapcsolat) */
		if (!connectedToBody) {
			orphanAge++;                 // <<<  minden körben NÖVELJÜK

			/* Healing-vég keresése visitorral */ //nincs használva semmire
			boolean healingEnd = hasHealingEnd();

			/* 3 kör után minden NEM-Healing ág leesik – akkor is, ha van Healing-vég */
			if (orphanAge >= ORPHAN_AGE_LIMIT) {
				removeOrphans();
			} else {
				orphanAge = 0;                                 // ismét van gyökér
			}

			/* 5) normál növekedés (változatlanul) */
			if (random) {
				if (new java.util.Random().nextInt(3) == 0) {
					lifeCycle = LifeCycle.Grown;
				}
			} else {
				lifeCycle = LifeCycle.Grown;
			}
		}
	}
	
	/**
	 * A fonal halálát megvalósító függvény.
	 * Visitor modell segítségével határozza meg, hogy milyen tektonon van a fonal. Ha healing típusún, akkor nem hal meg
	 * 
	 * @param strings A fonalakat tartalmazó lista, amely segít meghatározni a fonal halálát.
	 */
	public void die(ArrayList<MushroomString> strings) {
		KeepStringAliveVisitor v = new KeepStringAliveVisitor();
        for (MushroomString string : strings) {
            if (string.getMushroom() == mushroom && string.getNeighbours().get(0) == this) {
                TectonAccept acceptor = (TectonAccept) string.getConnection().get(0);
                acceptor.accept(v);
                if (!v.canPerformAction()) {
                    dead = true;
                }
            }
        }
	}

	public GeometryString getGeometry() {
		return geometry;
	}
}

================
File: src/main/java/control/KeyHandler.java
================
package main.java.control;

import main.java.GameController;
import main.java.GamePanel;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.HashMap;
import java.util.Map;

public class KeyHandler implements KeyListener {

    private int keyCode = -1; // alapértelmezett érték
    private final GameController game;
    private final Map<Integer, Boolean> keyMap = new HashMap<>();
    private final Runnable repaintCallback;
    private final GamePanel gamePanel;

    public static final int KEY_PASS = KeyEvent.VK_P;
    public static final int KEY_GROW_BODY = KeyEvent.VK_G;
    public static final int KEY_MUSHROOM = KeyEvent.VK_M;
    public static final int KEY_BRANCH = KeyEvent.VK_B;
    public static final int KEY_SPREAD_SPORE = KeyEvent.VK_S;
    public static final int KEY_HYPHA = KeyEvent.VK_H;
    public static final int KEY_EAT = KeyEvent.VK_E;
    public static final int KEY_CUT = KeyEvent.VK_C;
    public static final int KEY_MOVE = KeyEvent.VK_M;

    public KeyHandler(GameController gc, Runnable repaintCallback, GamePanel gamePanel) {
        game = gc;
        this.repaintCallback = repaintCallback;
        this.gamePanel = gamePanel;
    }

    @Override
    public void keyTyped(KeyEvent e) {}

    /**
     * Kezeli a billentyű lenyomás eseményeket.
     * Elmenti a lenyomott billentyű kódját.
     * @param e a billentyű esemény
     */
    @Override
    public void keyPressed(KeyEvent e) {
        keyCode = e.getKeyCode();
        keyMap.put(keyCode, true);

        System.out.println("Key pressed: " + (char)keyCode);

        switch (keyCode) {
            case KEY_PASS:
                gamePanel.setShineOn(GamePanel.ShineOn.NONE);
                if (game.getCurrentPlayer() != null && !game.getInit()) {
                    game.getCurrentPlayer().pass();
                    game.nextTurnCheck();
                    repaintCallback.run();
                    resetKeyCode();
                }
                break;
            case KEY_GROW_BODY:
                gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
                //Implementalas
                break;
            case KEY_MUSHROOM, KEY_HYPHA:
                gamePanel.setShineOn(GamePanel.ShineOn.MUSHBODY);
                break;
            case KEY_BRANCH, KEY_CUT:
                gamePanel.setShineOn(GamePanel.ShineOn.MUSHSTRING);
                break;
            case KEY_SPREAD_SPORE:
                gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
                break;
            //case KEY_MOVE:
            //    gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
            //    break;
            case KEY_EAT:
                gamePanel.setShineOn(GamePanel.ShineOn.SPORE);
                break;
            default:
                gamePanel.setShineOn(GamePanel.ShineOn.NONE);
                break;
        }
        //repaintCallback.run();
    }

    @Override
    public void keyReleased(KeyEvent e) {
        keyMap.put(e.getKeyCode(), false);
    }

    /**
     * Visszaadja az utoljára lenyomott billentyű kódját.
     * @return a keyCode
     */
    public int getKeyCode() {
        return keyCode;
    }
    public void resetKeyCode() {
        this.keyCode = -1;
    }

}

================
File: src/main/java/tecton/Tecton.java
================
package main.java.tecton;

import main.java.mushroom.MushroomString;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Random;
import java.util.function.Supplier;

/**
 * Absztrakt Tecton osztály, amely a játék mezőit reprezentálja.
 * Egyedi névvel rendelkezik, ezért a Nameable leszármazottja, valamint vannak szomszédai és eltárolja, hogy mennyi fonal lehet rajta maximálisan
 */
public abstract class Tecton implements Serializable {

    private ArrayList<Tecton> neighbours;
    private int maxStrings;
    private boolean bodyGrown = false;
    private GeometryTecton geometry;
    boolean dead = false;

    /**
     * Konstruktor: létrehoz egy új Tecton példányt megadott névvel és maximális fonalszámmal.
     *
     * @param maxStrings A maximálisan tárolható gombafonalak száma.
     */
    public Tecton(int maxStrings) {
        this.maxStrings = maxStrings;
        neighbours = new ArrayList<>();
    }

    // Getterek, Setterek
    public ArrayList<Tecton> getNeighbours() {
        return neighbours;
    }

    public void setNeighbours(ArrayList<Tecton> neighbours) {
        this.neighbours = neighbours;
    }

    public GeometryTecton getGeometry() {
        return this.geometry;
    }

    public void setGeometry(GeometryTecton geometry) {
        this.geometry = geometry;
    }

    public int getMaxStrings() {
        return maxStrings;
    }

    public void setMaxStrings(int maxStrings) {
        this.maxStrings = maxStrings;
    }

    public boolean getDead() {
        return dead;
    }

    public void setDead(boolean dead) {
        this.dead = dead;
    }
    
    /** @return true, ha már nőtt rajta egy MushroomBody. */
    public boolean hasSpace() {
        return !bodyGrown;
    }
    
    /** Jelzi, hogy ezután már nem lehet rajta új body. */
    public void markBodyGrown() {
        this.bodyGrown = true;
    }

    /**
     * Meghatározza az aktuális Tecton szomszédait egy lista alapján.
     *
     * @param allTectons Az összes tectont tartalmazó lista.
     * @return Az aktuális tecton szomszédainak listája.
     */
    public ArrayList<Tecton> determineNeighbours(ArrayList<Tecton> allTectons) {
        ArrayList<Tecton> result = new ArrayList<>();
        for (Tecton t : allTectons) {
            if (t != this && this.isNeighbour(t)) {
                result.add(t);
            }
        }
        return result;
    }

    /**
     * Meghatározza, hogy egy másik Tecton szomszédja-e az aktuálisnak. Ez akkor igaz, ha 400-nál kisebb a kettő távolsága
     */
    public boolean isNeighbour(Tecton t) {
        if (this.geometry == null || t.geometry == null) {
            return false;
        }
        double dx = this.geometry.getX() - t.geometry.getX();
        double dy = this.geometry.getY() - t.geometry.getY();
        double distance = Math.sqrt(dx * dx + dy * dy);
        System.out.println(distance);

        return distance <= 3000;
    }

    /**
     * Eldonti, hogy novesztheto-e új fonal. Atveszi a fonalak listáját, amin megvizsgálja, hogy hány fonal található ezen a tektonon.
     * Ha a maxStrings-mél kisebb, akkor van még rajta hely, különben nincs.
     *
     * @param strings A gombafonalakat tartalmazó lista.
     * @return true, ha még lehet új fonalat növeszteni; egyébként false.
     */
    public boolean canGrowHypha(ArrayList<MushroomString> strings) {
        int counter = 0;
        for (MushroomString string : strings) {
            if (string.getConnection().contains(this)) {
                counter++;
            }
        }
        return counter < maxStrings;
    }
    
    /**
     * A split logikáját konkrét leszármazottak valósítják meg.
     * Két új példányt ad vissza.
     */
    public abstract void createSplitTectons(ArrayList<Tecton> tectons, ArrayList<Tecton> newTectons);

    protected void createSplitTectonsWithFactory(Supplier<Tecton> factory, ArrayList<Tecton> newTectons) {
        if (this.getMaxStrings() == 1) {
            return;
        }
        int cx = this.getGeometry().getX();
        int cy = this.getGeometry().getY();
        int newRadius = this.getGeometry().getRadius() / 2;
        if(newRadius < 40) {
            return;
        }
        Random rng = new Random();
        double angle = rng.nextDouble() * 2 * Math.PI;

        float dx = (float) (Math.cos(angle) * this.getGeometry().getRadius() / 2);
        float dy = (float) (Math.sin(angle) * this.getGeometry().getRadius() / 2);

        GeometryTecton g1 = new GeometryTecton((int) (cx + dx), cy + (int)dy, newRadius);
        GeometryTecton g2 = new GeometryTecton((int) (cx - dx), cy - (int)dy, newRadius);

        Tecton t1 = factory.get();
        Tecton t2 = factory.get();

        t1.setMaxStrings(this.getMaxStrings() - 1);
        t2.setMaxStrings(this.getMaxStrings() - 1);
        t1.setGeometry(g1);
        t2.setGeometry(g2);

        newTectons.add(t1);
        newTectons.add(t2);
    }

}

================
File: src/main/java/insect/Insect.java
================
package main.java.insect;

import java.io.Serializable;
import java.util.ArrayList;
import main.java.tecton.*;
import main.java.mushroom.*;
import main.java.Geometry;
import main.java.Updatable;

/**
 * Az insect osztály a játékban megjelenő rovarokat reprezentálja.
 * A Nameable leszármazottja, így nevet tárol, és különféle képességekkel rendelkezik:
 * mozgás, fonalvágás, spórák elfogyasztása és állapotváltozás.
 */
public class Insect implements Updatable, Serializable {

	private int collectedNutrients;
	private Tecton location;
	private boolean canCutString;
	private boolean canMove;
	/**
     * A rovar sebességét meghatározó enum.
     */
	public enum Speed { SLOW, NORMAL, FAST }
	private Speed speed;
	private boolean dead;
	private Geometry geometry;

	/**
     * Konstruktor – új rovar létrehozása.
     *
     * @param location A rovar kezdeti helye.
     */
	public Insect(Tecton location) {
		canCutString = true;
		canMove = true;
		speed = Speed.NORMAL;
		collectedNutrients = 0;
		this.location = location;
		dead = false;
	}

	/**
     * Az Updatable interfész felüldefiniált update függvénye. 
     * Visszaállítja a rovar állapotát alapértelmezettre.
     *
     * @param testing A tesztelő állapot eldöntését meghatározó boolean.
     */
	public void update(boolean testing){
		speed = Speed.NORMAL;
		canMove = true;
		canCutString = true;
	}

	//Getterek, Setterek
	public boolean getCanCutString() 
	{
		return canCutString;
	}
	public boolean getCanMove()
	{
		return !canMove;
	}
	public boolean getDead()
	{
		return dead;
	}
	public Tecton getLocation()
	{
		return location;
	}
	public int getNutrients(){
		return collectedNutrients;
	}
	
	public Geometry getGeometry() {
		return geometry;
	}
	
	public void setGeometry(Geometry geometry) {
		this.geometry = geometry;
	}
	
	public void setCollectedNutrients(int n)
	{
		collectedNutrients += n;
	}
	public void setCanMove(boolean canMove) {
		this.canMove = canMove;
	}
	public void setCanCutString(boolean canCutString) {
		this.canCutString = canCutString;
	}
	public void setSpeed(Speed speed)
	{
		this.speed = speed;
	}

	/**
     * A rovar mozgatása egy új tectonra.
     * A mozgás sebességtől függően extra vagy csökkentett akcióval jár.
     *
     * @param destination Az új tecton, ahova mozogni szeretne.
     * @return +1, ha FAST; -1, ha SLOW; 0 egyébként vagy ha nem tud mozogni.
     */
	public int move(Tecton destination) {
		if(canMove && location != destination){
			location = destination;
			if(speed == Insect.Speed.FAST) {
                return 1;
			}
			else if(speed == Insect.Speed.SLOW) {
				return -1;
			}
			else {
				return 0;
			}
		}
		return 0;
	}

	 /**
     * A megadott gombafonal elvágása.
     *
     * @param ms      Az elvágandó gombafonal.
     * @param strings Az összes fonalat tartalmazó lista.
     */
	public void cutHypha(MushroomString ms, ArrayList<MushroomString> strings)
	{
	    // 1) ellenőrizzük, hogy azon a Tectonon állunk-e, ahol a fonal egyik vége van
	    if (!ms.getConnection().contains(location)) return;

	    /* 2) keressük meg a szomszéd fonalat (ha volt) */
	    for (MushroomString nb : ms.getNeighbours()) {
	        if (nb == null) continue;

	        // a neighbour listájából is eltávolítjuk ms-t
	        if (nb.getNeighbours().get(0) == ms) nb.getNeighbours().set(0, null);
	        if (nb.getNeighbours().size() > 1 && nb.getNeighbours().get(1) == ms)
	            nb.getNeighbours().set(1, null);

	        // ms neighbour-listájából töröljük nb-t
	        if (ms.getNeighbours().get(0) == nb) ms.getNeighbours().set(0, null);
	        if (ms.getNeighbours().size() > 1 && ms.getNeighbours().get(1) == nb)
	            ms.getNeighbours().set(1, null);
	    }

	    /* 3) az elvágott fonalról levágjuk a másik Tectont,
	          így „félfonal” marad (csak location marad benne) */
	    if (ms.getConnection().size() == 2) {

	        // 2.a  Meghatározzuk, melyik végpont marad a rovar alatt,
	        //       és melyik „esik le”
	        Tecton dropped;
	        if (ms.getConnection().get(0) == location) {
	            dropped = ms.getConnection().remove(1);
	        } else {
	            dropped = ms.getConnection().remove(0);
	        }

	        // 2.b  Új fél-fonal létrehozása a leeső Tectonon
	        ArrayList<Tecton> newConn = new ArrayList<>();
	        newConn.add(dropped);

	        MushroomString clone = new MushroomString(
	            MushroomString.nextCloneName(ms.getName()),
	            ms.getMushroom(),
	            newConn,
	            new ArrayList<>(java.util.Arrays.asList(null, null)),
	            ms.getLifeLine(),
				ms.getGeometry()
	        );

	        // 2.c  Szomszédlista frissítése
	        ms.getNeighbours().removeIf(clone::equals);           // biztosan kiveszi a klónt
	        while (ms.getNeighbours().size() < 2) ms.getNeighbours().add(null);  // feltölt null-lal

	        // 2.d  Belerakjuk a bolygó globális listájába, hogy a LIST parancs is lássa
	        strings.add(clone);
	    }

	    // 4) NEM ölünk meg semmit azonnal – a MushroomString.update végzi az öregedést
	}
	
	/**
     * A rovar elpusztul – halott állapotba kerül.
     */
	public void die()
	{
		dead = true;
	}

}

================
File: src/main/java/Main.java
================
package main.java;

import main.java.view.UtilityTool;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

/*
 * A Main osztály felelős a program kiindulási pontjáért, innen hívódik meg a main függvény.
 */
public class Main {

    private static final UtilityTool uTool = new UtilityTool();

	public static void main(String[] args) {
        JFrame frame = new JFrame();

		BufferedImage logo = uTool.load(MainMenu.prefix + "mb_big.png");
		frame.setIconImage(logo);

        MainMenu menu = new MainMenu(frame);
		menu.setBackground(new Color(6, 26, 14));

		frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
		frame.add(menu);
		frame.setVisible(true);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}

================
File: src/main/java/view/DefaultInsectDrawer.java
================
package main.java.view;

import java.awt.*;
import java.awt.image.BufferedImage;

import main.java.MainMenu;
import main.java.insect.Insect;


public class DefaultInsectDrawer extends UtilityTool implements InsectDrawer {

    private final BufferedImage image;

    DefaultInsectDrawer(){
        image = load(MainMenu.prefix + "insect_icon3.png");
    }

    @Override
    public void draw(Graphics2D g2, Insect insect) {
        int width = 40;
        int height = 40;
        g2.drawImage(image, (int)insect.getGeometry().getX(), (int)insect.getGeometry().getY(), width, height, null);
    }

}

================
File: src/main/java/view/DefaultSporeDrawer.java
================
package main.java.view;

import java.awt.*;
import java.awt.image.BufferedImage;

import main.java.MainMenu;
import main.java.spore.Spore;


public class DefaultSporeDrawer extends UtilityTool implements SporeDrawer {

    public static final int SIZE = 30;
    private final BufferedImage image;
    DefaultSporeDrawer() {
        image = load(MainMenu.prefix + "spore.png");
    }

    @Override
    public void draw(Graphics2D g2, Spore spore) {
        g2.drawImage(image, (int) (spore.getGeometry().getX() - SIZE / 2), (int) (spore.getGeometry().getY() - SIZE / 2), SIZE, SIZE, null);
    }
}

================
File: src/main/java/view/DefaultMushroomBodyDrawer.java
================
package main.java.view;

import java.awt.*;
import java.awt.image.BufferedImage;

import main.java.MainMenu;
import main.java.mushroom.*;

public class DefaultMushroomBodyDrawer extends UtilityTool implements MushroomBodyDrawer {

    private final BufferedImage shortImage;
    private final BufferedImage grownImage;
    private final BufferedImage mediumImage;

    DefaultMushroomBodyDrawer() {
        shortImage = load(MainMenu.prefix + "mb_small.png");
        mediumImage = load(MainMenu.prefix + "mb_medium.png");
        grownImage = load(MainMenu.prefix + "mb_big.png");
    }

    @Override
    public void draw(Graphics2D g2, MushroomBody mb) {
        BufferedImage image;
        switch(mb.getState()){
            case "SMALL" :
                image = shortImage;
                break;
            case "MEDIUM" :
                image =mediumImage;
                break;
            case "BIG" :
                image = grownImage;
                break;
            default :
                image = shortImage;
                break;
        }

        int width = 50;
        float drawX = mb.getGeometry().getX() - (float) width /2;
        int height = 50;
        float drawY = mb.getGeometry().getY() - (float) height /2;

        g2.drawImage(image, (int) drawX, (int) drawY, width, height, null);
    }

}

================
File: src/main/java/view/DrawManager.java
================
package main.java.view;


import java.awt.*;

import main.java.GamePanel;
import main.java.Planet;
import main.java.tecton.*;
import main.java.mushroom.*;
import main.java.insect.Insect;
import main.java.spore.Spore;

public class DrawManager {
    private DefaultTectonDrawer tectonDrawer;
    private DefaultSporeDrawer sporeDrawer;
    private DefaultMushroomBodyDrawer mushroomBodyDrawer;
    private DefaultMushroomStringDrawer mushroomStringDrawer;
    private DefaultInsectDrawer insectDrawer;

    public DrawManager(){
        setDrawers(new DefaultDrawingFactory());
    }

    public void setDrawers(DrawingFactory factory){
        this.tectonDrawer = factory.createTectonDrawer();
        this.insectDrawer = factory.createInsectDrawer();
        this.sporeDrawer = factory.createSporeDrawer();
        this.mushroomStringDrawer = factory.createMushroomStringDrawer();
        this.mushroomBodyDrawer = factory.createMushroomBodyDrawer();
    }

    public void drawTecton(Graphics2D g, Tecton t, boolean shining){
        if(shining){
            drawShineEffect(g, (int) t.getGeometry().getX(), (int) t.getGeometry().getY(), (int) (t.getGeometry().getRadius() + 10));
        }
        tectonDrawer.draw(g, t);
    }

    public void drawSpore(Graphics2D g, Spore spore, boolean shining) {
        if(shining){
            drawShineEffect(g, (int) spore.getGeometry().getX(), (int) spore.getGeometry().getY(), 25);
        }
        sporeDrawer.draw(g, spore);
    }

    public void drawMushroomBody(Graphics2D g, MushroomBody mushroomBody, boolean shining) {
        if(shining) {
            drawShineEffect(g, (int) mushroomBody.getGeometry().getX(), (int) mushroomBody.getGeometry().getY(), 35);
        }
        mushroomBodyDrawer.draw(g, mushroomBody);
    }

    public void drawMushroomString(Graphics2D g, MushroomString mushroomString,boolean shining){
        if(shining) {
            int midX = (mushroomString.getGeometry().getX() +mushroomString.getGeometry().getX2() ) / 2;
            int midY = (mushroomString.getGeometry().getY() +mushroomString.getGeometry().getY2()) / 2;
            drawShineEffect(g, midX, midY, 30);
        }
        mushroomStringDrawer.draw(g, mushroomString);
    }

    public void drawInsect(Graphics2D g, Insect insect, boolean shining) {
        if(shining) {
            drawShineEffect(g, (int) (insect.getGeometry().getX() + 20), (int) (insect.getGeometry().getY() + 20), 30);
        }
        insectDrawer.draw(g, insect);
    }

    public void drawPlanet(Graphics2D g, Planet p, GamePanel.ShineOn shining) {
    	for(Tecton t : p.getTectons()) {
    		drawTecton(g, t, shining == GamePanel.ShineOn.TECTON);
    	}
    	
    	for(MushroomBody b : p.getMushbodies()) {
    		drawMushroomBody(g, b, shining == GamePanel.ShineOn.MUSHBODY);
    	}

        for(MushroomString ms : p.getMushstrings()) {
            if (ms.getConnection().size() >= 2) {
                Tecton t1 = ms.getConnection().get(0);
                Tecton t2 = ms.getConnection().get(1);
                drawMushroomString(g, ms,
                        shining == GamePanel.ShineOn.MUSHSTRING);
            }
        }
    	
    	for(Insect i : p.getInsects()) {
    		drawInsect(g, i, shining == GamePanel.ShineOn.INSECT);
    	}
    	
    	for(Spore sp : p.getSpores()) {
    		drawSpore(g, sp, shining == GamePanel.ShineOn.SPORE);
    	}
    }

    // Új metódus a kiemelő effekt rajzolásához
    private void drawShineEffect(Graphics2D g, int x, int y, int radius) {
        // Mentjük az eredeti beállításokat
        Composite originalComposite = g.getComposite();
        Color originalColor = g.getColor();
        Stroke originalStroke = g.getStroke();

        // Átlátszó fénylő köröket rajzolunk az objektum köré
        for (int i = 0; i < 5; i++) {
            float alpha = 0.1f - (i * 0.015f);
            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
            g.setColor(Color.YELLOW);
            g.setStroke(new BasicStroke(5 - i));
            g.drawOval(x - (radius + i*4), y - (radius + i*4), (radius + i*4) * 2, (radius + i*4) * 2);
        }

        // Visszaállítjuk az eredeti beállításokat
        g.setComposite(originalComposite);
        g.setColor(originalColor);
        g.setStroke(originalStroke);
    }

}

================
File: src/main/java/Planet.java
================
package main.java;

import java.io.Serial;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Random;

import main.java.insect.*;
import main.java.player.Player;
import main.java.player.PlayerAccept;
import main.java.tecton.*;
import main.java.mushroom.*;
import main.java.spore.*;

/**
 * A Planet osztály felelős a játék világának kezeléséért, amely magába foglalja a különböző objektumokat
 * (például tektonok, gombák, spórák, rovarok).
 */
public class Planet implements Updatable, Serializable {
    @Serial
    private static final long serialVersionUID = 1L;

    private final ArrayList<Tecton> tectons;
    private final ArrayList<MushroomBody> mushbodies;
    private final ArrayList<MushroomString> mushstrings;
    private final ArrayList<Insect> insects;
    private final ArrayList<Spore> spores;

    
    /**
     * A Planet osztály konstruktora, amely inicializálja az objektumo listáit.
     */
    public Planet() {
        tectons = new ArrayList<>();
        mushbodies = new ArrayList<>();
        mushstrings = new ArrayList<>();
        insects = new ArrayList<>();
        spores = new ArrayList<>();
    }

    /**
     * Hozzáad egy tekton objektumot a listához.
     *
     * @param tecton a hozzáadandó Tecton
     */
    public void addTecton(Tecton tecton) {
        tectons.add(tecton);
    }

    public void addMushroomString(MushroomString ms) {
        mushstrings.add(ms);
    }
    
    //Getterek, Setterek
    public ArrayList<Tecton> getTectons() {
        return tectons;
    }

    public ArrayList<MushroomBody> getMushbodies() {
    	return mushbodies;
    }

    public ArrayList<MushroomString> getMushstrings() {
    	return mushstrings;
    }

    public ArrayList<Insect> getInsects() {
    	return insects;
    }

    public ArrayList<Spore> getSpores() {
    	return spores;
    }
    
    /**
     * Megnézi, hogy van-e spóra egy adott mushroomString tektonján.
     *
     * @param ms A vizsgált MString
     */
    private boolean checkForSpores(MushroomString ms) {
	    if (ms.getConnection().isEmpty()) {
            return false;
        }
	    Tecton location = ms.getConnection().get(0);
	    return spores.stream().anyMatch(spore -> spore.getLocation() == location);
	}
    
    public void checkForBodyConnection() {
    	for (MushroomString ms : mushstrings) {
    	    ms.setConnectedToBody(false);
    	}
    	for (MushroomBody mb : mushbodies) {
    	    if (mb.getDead()) {
                continue;
            }
    	    ArrayList<MushroomString> q = new ArrayList<>();
    	    for (MushroomString s : mushstrings) {
    	        if (!s.getDead() && s.getConnection().contains(mb.getLocation())) {
    	            q.add(s);
    	        }
    	    }

            while (!q.isEmpty()) {
                MushroomString cur = q.remove(0);
    	        if (cur.isConnectedToBody()) {
                    continue;
                }
    	        cur.setConnectedToBody(true);
    	        for (MushroomString n : cur.getNeighbours()) {
                    if (n != null && !n.getDead()) {
                        q.add(n);
                    }
    	        }
    	    }
        }
    }
    
    /**
     * Ha egy Tectonon egyszerre van
     *   – legalább egy élő, bénult rovar (canMove == false) ÉS
     *   – legalább egy élő MushroomString, amelynek egyik vége ezen a Tectonon van,
     * akkor a helyen nőjön egy új MushroomBody ugyanahhoz a gombához, mint a fonal.
     */
    public void growBodyOnParalyzedInsect() {

        // végigmegyünk az összes Tectonon
        for (Tecton t : tectons) {
            // 1) van-e bénult (canMove == false) élő rovar?
            boolean hasParalyzed = insects.stream().anyMatch(in -> !in.getDead() && in.getLocation() == t && in.getCanMove());
            if (!hasParalyzed) {
                continue;
            }

            // 2) élő fonal a Tectonon?
            for (MushroomString ms : mushstrings) {
                if (ms.getDead()) {
                    continue;
                }
                if (!ms.getConnection().contains(t)) {
                    continue;
                }

                // 3) nincs-e már ott gombatest?
                boolean bodyAlreadyHere = mushbodies.stream().anyMatch(mb -> !mb.getDead() && mb.getLocation() == t);
                if (bodyAlreadyHere) {
                    break;
                }

                // 4) létrehozzuk az új testet
                MushroomBody nb = new MushroomBody(
                        t,                                     // hely
                        ms.getMushroom(),                      // ugyanahhoz a gombához tartozzon
                        0,                                     // kezdeti state = kicsi
                        false                                  // testing flag
                );

                mushbodies.add(nb);

                // 5) a fonalat összekötjük a testtel, hogy élő kapcsolat legyen
                ms.setConnectedToBody(true);
               
                // 6) a bénult rovar(ok) elpusztítása ugyanazon a Tectonon
                for (Insect in : insects) {
                    if (!in.getDead() && in.getLocation() == t && in.getCanMove()) {
                        in.die();
                    }
                }
                // csak egy testet csíráztatunk fonalonként
                break;
            }
        }
    }
    
    /**
     * Az Updatable interfész felüldefiniált update függvénye. 
     * A plnaet által tárolt objektumok mindegyikén meghívja az update()-t
     *
     * @param random A tesztelő állapot eldöntését meghatározó boolean. Be/kikapcsolja a randomitást.
     */
    @Override
    public void update(boolean random) {
    	growBodyOnParalyzedInsect();
        insects.forEach(i -> i.update(random));
        mushbodies.forEach(mb -> mb.update(random));
        for (MushroomString ms : mushstrings) {
            boolean shouldUpdateRandomly = (ms.getLifeCycle() != MushroomString.LifeCycle.Child) || !checkForSpores(ms);
            ms.update(shouldUpdateRandomly);
        }
        ArrayList<Tecton> newTectons = new ArrayList<>();
        for (Tecton t : tectons) {
            if(random) {
                Random rng = new Random();
                int n = rng.nextInt(10000);
                if(n == 0) {
                    t.createSplitTectons(tectons, newTectons);
                    t.setDead(true);
                    removeObjectFromSplitTectons(t);
                }
            }
        }
        tectons.addAll(newTectons);
        System.out.println("Tectonok száma: " + tectons.size());
        for(Tecton t : tectons) {
            t.determineNeighbours(tectons);
            for(Tecton t2 : t.getNeighbours()) {
                //System.out.println();
            }
        }
    }

    /**
     * Törli azokat az objektumokat a világban, amelyek meghaltak. Fonalak esetén vár egy, vagy két kört annak függvényében, hogy mennyire kifejlett a fonal.
     * @param currentTurn Az aktuális kör száma
     */
    public void deleteDeadObjects(int currentTurn, ArrayList<Player> players) {
    	mushbodies.removeIf(MushroomBody::getDead);
    	mushstrings.removeIf(ms -> ms.getDead() &&
            ((ms.getLifeCycle() == MushroomString.LifeCycle.Child && currentTurn - ms.getLifeLine() >= 1) ||
            (ms.getLifeCycle() == MushroomString.LifeCycle.Grown && currentTurn - ms.getLifeLine() >= 2)));
    	insects.removeIf(Insect::getDead);
    	spores.removeIf(Spore::getDead);
    	RemoveInsectVisitor v = new RemoveInsectVisitor();
    	for(Player player : players) {
    		((PlayerAccept) player).accept(v);
    	}
        tectons.removeIf(Tecton::getDead);
    }
    private void removeObjectFromSplitTectons(Tecton t) {
        mushbodies.removeIf(mb -> mb.getLocation() == t);
        for (MushroomString ms : mushstrings) {
            ms.getConnection().remove(t);
        }
        insects.removeIf(i->i.getLocation() == t);
        spores.removeIf(s -> s.getLocation() == t);
    }
    
    /**
     * Újraszámolja az összes tekton szomszédait a Planet aktuális tekton listája alapján.
     */
    public void recalcNeighbours() {
        for (Tecton t : tectons) {
            ArrayList<Tecton> newNeighbours = t.determineNeighbours(tectons);
            t.setNeighbours(newNeighbours);
        }
    }

    /**
     * Megkeresi a dead állapotó gombatesteket, és dead-re állítja a hozzá kapcsolódó MString-eket is.
     *
     */
    public void checkForDeadShrooms(){
    	for(MushroomBody b : mushbodies) {
            if (b.getRemainingSporulation() == 0) {
                b.die(mushstrings);
            }
        }
    }
}

================
File: src/main/java/GameMenu.java
================
package main.java;

import main.java.console.ConsoleHandler;
import main.java.view.UtilityTool;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * A játékbeli menü megvalósításáért felelős osztály.
 */
public class GameMenu extends JMenuBar {

        GameController gameController;
        JButton b1, b2, b3, b4;
        JFrame frame;

        Color baseColor = new Color(47, 84, 39);
        Color hoverColor = new Color(75, 125, 64);

        public GameMenu(JFrame frame, GameController gameController) {
            this.frame = frame;
            this.gameController = gameController;
            setBackground(Color.LIGHT_GRAY);
            UtilityTool uTool = new UtilityTool();

            //Gombok
            BufferedImage b1Image = uTool.load(MainMenu.prefix + "b2.png");
            b1 = new JButton("");
            b1.setMargin(new Insets(0,0,0,0));
            b1.setIcon(new ImageIcon(b1Image));
            styleButton(b1);

            b2 = new JButton("Load");
            styleButton(b2);

            b3 = new JButton("Exit");
            styleButton(b3);

            b4 = new JButton("Developer Console");
            styleButton(b4);

            b1.addActionListener(e -> {
                if (GameFileChooser.saveGame(frame, gameController)) {
                    JOptionPane.showMessageDialog(frame, "Játékállapot sikeresen elmentve!", "Mentés sikeres", JOptionPane.INFORMATION_MESSAGE);
                }
            });

            b2.addActionListener(e -> {
                if (GameFileChooser.loadGame(frame, frame)) {
                    JOptionPane.showMessageDialog(frame, "Játékállás sikeresen betöltve!", "Betöltés sikeres", JOptionPane.INFORMATION_MESSAGE);
                }
            });

            b4.addActionListener(e -> {
                ConsoleHandler consoleHandler = new ConsoleHandler();
                consoleHandler.startConsoleInput();
            });

            b3.addActionListener(e -> {
                System.out.println("exit");
                frame.setJMenuBar(null);
                frame.getContentPane().removeAll();
                MainMenu menu = new MainMenu(frame);
                menu.setBackground(new Color(6, 26, 14));
                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
                frame.add(menu);
                frame.setVisible(true);
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                MenuSelectionManager.defaultManager().clearSelectedPath();
                frame.revalidate();
                frame.repaint();
            });

            JMenu menu = new JMenu("Menu");
            menu.add(b1);
            menu.add(b2);
            menu.add(b4);
            menu.add(b3);

            this.setPreferredSize(new Dimension(100, 20));
            this.add(menu);
        }

        /**
         * A játékbeli gombok stílusát állítja be.
         */
        private void styleButton(JButton button){

            button.setContentAreaFilled(true);
            button.setBorderPainted(true);
            button.setOpaque(true);
            button.setForeground(Color.WHITE);
            button.setBackground(baseColor);

            Dimension size = new Dimension(150, 25);
            button.setPreferredSize(size);
            button.setMinimumSize(size);
            button.setMaximumSize(size);


            button.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseEntered(java.awt.event.MouseEvent evt) {
                    button.setBackground(hoverColor);
                }

                public void mouseExited(java.awt.event.MouseEvent evt) {
                    button.setBackground(baseColor);
                }
            });
        }
}

================
File: src/main/java/control/MouseHandler.java
================
package main.java.control;

import main.java.GameController;
import main.java.GamePanel;
import main.java.Geometry;
import main.java.insect.Insect;
import main.java.mushroom.GeometryString;
import main.java.mushroom.MushroomBody;
import main.java.mushroom.MushroomString;
import main.java.player.Insecter;
import main.java.player.Player;
import main.java.player.Shroomer;
import main.java.spore.Spore;
import main.java.spore.SporeAccept;
import main.java.spore.SporeConsumptionVisitor;
import main.java.tecton.GeometryTecton;
import main.java.tecton.Tecton;

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * A MouseHandler osztály felelős az egér események kezeléséért.
 * Kezeli a kattintásokat és az egér mozgását a felhasználói felületen.
 */
public class MouseHandler implements MouseListener {

    private final GameController gc;
    private boolean firstClick = true;
    private Spore clickedSpore = null;
    private Insect clickedInsect = null;
    private Tecton clickedTecton = null;
    private final KeyHandler keyHandler;
    private final Runnable repaintCallback;
    private MushroomBody clickedMushroomBody = null;
    private MushroomString clickedMushroomString = null;
    private final GamePanel gamePanel;

    public MouseHandler(GameController gc, Runnable repaintCallback, GamePanel gamePanel, KeyHandler keyHandler) {
        this.gc = gc;
        this.repaintCallback = repaintCallback;
        this.keyHandler = keyHandler;
        this.gamePanel = gamePanel;
    }

    private void reset(){
        firstClick = true;
        clickedSpore = null;
        clickedInsect = null;
        clickedTecton = null;
        clickedMushroomBody = null;
        clickedMushroomString = null;
        gamePanel.setShineOn(GamePanel.ShineOn.NONE);
    }

    /**
     * Egy tekton kiválasztása. Megvizsgálja, hogy a kattintás pozíciója ráesik-e egy objektumra.
     * @param x a kattintás x koordinátája
     * @param y a kattintás y koordinátája
     */
    private void selectTecton(int x, int y) {
        // Beállítjuk a kiemelést a tektonokra
        gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
        repaintCallback.run();
        for (Tecton t : gc.getPlanet().getTectons()) {
            float tx = t.getGeometry().getX();
            float ty = t.getGeometry().getY();
            float radius = t.getGeometry().getRadius();
            if ((x <= (tx + radius) && x >= (tx - radius)) && (y <= (ty + radius) && y >= (ty - radius))) {
                clickedTecton = t;
                //System.out.println("selected tecton: " + clickedTecton.getName());
                break;
            }
        }
    }

    /**
     * Egy gombatest kiválasztása. Megvizsgálja, hogy a kattintás pozíciója ráesik-e egy objektumra.
     * @param x a kattintás x koordinátája
     * @param y a kattintás y koordinátája
     */
    private void selectMushroomBody(int x, int y) {
        // Beállítjuk a kiemelést a gombatestekre
        gamePanel.setShineOn(GamePanel.ShineOn.MUSHBODY);
        repaintCallback.run();
        for (MushroomBody mb : gc.getPlanet().getMushbodies()) {
            float tx = mb.getGeometry().getX();
            float ty = mb.getGeometry().getY();
            int radius = 45;
            if ((x <= (tx + radius) && x >= (tx - radius)) && (y <= (ty + radius) && y >= (ty - radius))
                    && ((Shroomer) gc.getCurrentPlayer()).getMushroom().equals(mb.getMushroom())) {
                clickedMushroomBody = mb;
                //System.out.println("Selected body: " + mb);
                break;
            }
        }
    }

    /**
     * Egy rovar kiválasztása. Megvizsgálja, hogy a kattintás pozíciója ráesik-e egy objektumra.
     * @param x a kattintás x koordinátája
     * @param y a kattintás y koordinátája
     */
    private void selectInsect(int x, int y) {
        // Beállítjuk a kiemelést a rovarokra
        gamePanel.setShineOn(GamePanel.ShineOn.INSECT);
        repaintCallback.run();
        for (Insect i : gc.getPlanet().getInsects()) {
            float tx = i.getGeometry().getX();
            float ty = i.getGeometry().getY();
            int radius = 45;
            if ((x <= (tx + radius) && x >= (tx - radius)) && (y <= (ty + radius) && y >= (ty - radius))
                    && ((Insecter) gc.getCurrentPlayer()).getInsects().contains(i)) {
                clickedInsect = i;
                //System.out.println("Selected insect: " + i);
                break;
            }
        }
    }

    /**
     * Egy spóra kiválasztása. Megvizsgálja, hogy a kattintás pozíciója ráesik-e egy objektumra.
     * @param x a kattintás x koordinátája
     * @param y a kattintás y koordinátája
     */
    private void selectSpore(int x, int y) {
        // Beállítjuk a kiemelést a spórákra
        gamePanel.setShineOn(GamePanel.ShineOn.SPORE);
        repaintCallback.run();
        for (Spore s : gc.getPlanet().getSpores()) {
            float tx = s.getGeometry().getX();
            float ty = s.getGeometry().getY();
            int radius = 35;
            if ((x <= (tx + radius) && x >= (tx - radius)) && (y <= (ty + radius) && y >= (ty - radius))) {
                clickedSpore = s;
                System.out.println("Selected spore: " + s.getName());
                break;
            }
        }
    }

    /**
     * Egy fonal kiválasztása. Megvizsgálja, hogy a kattintás pozíciója ráesik-e egy objektumra.
     * @param x a kattintás x koordinátája
     * @param y a kattintás y koordinátája
     */
    private void selectMushroomString(int x, int y) {
        // Beállítjuk a kiemelést a gombafonalokra
        gamePanel.setShineOn(GamePanel.ShineOn.MUSHSTRING);
        repaintCallback.run();
        for (MushroomString ms : gc.getPlanet().getMushstrings()) {
            ArrayList<Tecton> connections = ms.getConnection();

            Geometry geom1;
            Geometry geom2;
            // Az összekötött tektonok geometriáját lekérjük
            if(connections.get(1) != null){
                 geom1 = connections.get(0).getGeometry();
                 geom2 = connections.get(1).getGeometry();
                 System.out.println("Büdös kurva anyád");
            }
            else{
                geom1 = new Geometry(ms.getGeometry().getX(), ms.getGeometry().getY());
                geom2 = connections.get(0).getGeometry();
                System.out.println("Buzi románok");
            }

            // Csak akkor folytatjuk, ha elég közel van a klikk a fonalhoz
            if (isClickNearLine(x, y, geom1.getX(), geom1.getY(), geom2.getX(), geom2.getY())) {
                System.out.println("Clicked on a mushroom string");
                // Ha a current player Shroomer, akkor megnézzük, hogy az ő gombájának fonala-e
                if (gc.getCurrentPlayer() instanceof Shroomer shroomer) {
                    if (ms.getMushroom() == shroomer.getMushroom() && !ms.getDead()) {
                        clickedMushroomString = ms;
                        System.out.println("Selected mushroom string: " + ms.getName());
                        return;
                    }
                } else if (gc.getCurrentPlayer() instanceof Insecter) {
                    if (!ms.getDead()) {
                        clickedMushroomString = ms;
                        System.out.println("Selected mushroom string: " + ms.getName());
                        return;
                    }
                }
            }
        }
    }

    /**
     * Eldönti, hogy egy kattintás eléggé közel volt-e egy fonalhoz
     * @param clickX X koordinátája a kattintásnak
     * @param clickY Y koordinátája a kattintásnak
     * @param x1 X koordinátája a fonal elejének
     * @param y1 Y koordinátája a fonal elejének
     * @param x2 X koordinátája a fonal végének
     * @param y2 Y koordinátája a fonal végének
     * @return igaz, ha a kattintás eléggé közel esik a fonalhoz
     */
    private boolean isClickNearLine(int clickX, int clickY, float x1, float y1, float x2, float y2) {
        final int THRESHOLD = 10;

        double lineLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        System.out.println("Line length: " + lineLength);
        if (lineLength == 0) return false;

        double distance = Math.abs((x2 - x1) * (y1 - clickY) - (x1 - clickX) * (y2 - y1)) / lineLength;
        System.out.println("Distance: " + distance);
        if (distance > THRESHOLD) return false;

        double dotProduct = ((clickX - x1) * (x2 - x1) + (clickY - y1) * (y2 - y1)) / (lineLength * lineLength);
        System.out.println("Dot product: " + dotProduct);
        return dotProduct >= 0 && dotProduct <= 1;
    }

    /**
     * Az inicializációs fázis kattintása (ha shroomer, akkor kifejlett gombatestet, máskülönben rovart tesz le a kattintott tektonra)
     * @param p A játékos, aki végzi a kattintást
     * @param mouseX a kattintás x koordinátája
     * @param mouseY a kattintás y koordinátája
     */
    private void initClick(Player p, int mouseX, int mouseY) {
        System.out.println("Clicked at " + mouseX + ", " + mouseY);
        selectTecton(mouseX, mouseY);

        if (clickedTecton != null) {
            if (p instanceof Shroomer) {
                MushroomBody mb = new MushroomBody(clickedTecton, ((Shroomer) p).getMushroom(), 2, false);
                for(MushroomBody m : gc.getPlanet().getMushbodies()) {
                    if(m.getLocation().equals(clickedTecton)) {
                        return;
                    }
                }

                // Setting geometry for mushroom body
                GeometryTecton tectonGeometry = clickedTecton.getGeometry();
                mb.setGeometry(gc.randomOffsetInsideCircle(tectonGeometry));

                gc.getPlanet().getMushbodies().add(mb);
            } else if (p instanceof Insecter) {
                for(Insect i : gc.getPlanet().getInsects()) {
                    if(i.getLocation().equals(clickedTecton)) {
                        return;
                    }
                }
                Insect i = new Insect(clickedTecton);

                // THIS IS THE FIX - Set geometry for the insect
                GeometryTecton tectonGeometry = clickedTecton.getGeometry();
                i.setGeometry(gc.randomOffsetInsideCircle(tectonGeometry));

                gc.getPlanet().getInsects().add(i);
                ((Insecter) p).addInsect(i);
            }
            gc.setInitCheck();
            gc.setCurrentPlayerToNextPlayer();
            reset();
        }
    }

    /**
     * Az éles játék kattintásának feldolgozása, ha ez az "első kattintás"
     * @param p A játékos, aki végzi a kattintást
     * @param mouseX a kattintás x koordinátája
     * @param mouseY a kattintás y koordinátája
     */
    private void firstGameClick(Player p, int mouseX, int mouseY) {
        if(p instanceof Shroomer) {
            int code = keyHandler.getKeyCode();
            System.out.println("Current keyCode: " + code);
            //System.out.println("Clicked at " + mouseX + ", " + mouseY);
            //A gombára,vagy fonalra mehet
            if(keyHandler.getKeyCode() == KeyHandler.KEY_MUSHROOM){ // click on mushroom
                System.out.println("Mushroom at " + mouseX + ", " + mouseY);
                selectMushroomBody(mouseX, mouseY);
                keyHandler.resetKeyCode();
            }
            else if(keyHandler.getKeyCode() == KeyHandler.KEY_BRANCH) { // branch existing hypha
                selectMushroomString(mouseX, mouseY);
            }

            if(clickedMushroomBody != null || clickedMushroomString != null)
                firstClick = false; //Ha spórás tektonra kattint, akkor a firstClick marad true, hiszen az új test növesztése már nem igényel további kattintást
        }
        else if(p instanceof Insecter) {
            System.out.println("Clicked at " + mouseX + ", " + mouseY);
            //A kattintás egy rovarra mehet, amivel cselekedni akarunk
            selectInsect(mouseX, mouseY);
            if (clickedInsect != null) {
                firstClick = false;
            }
        }
    }

    /**
     * Az éles játék kattintásának feldolgozása, ha ez a "második kattintás"
     * @param p A játékos, aki végzi a kattintást
     * @param mouseX a kattintás x koordinátája
     * @param mouseY a kattintás y koordinátája
     */
    private void secondGameClick(Player p, int mouseX, int mouseY){
        System.out.println("Second click at " + mouseX + ", " + mouseY);
        if(p instanceof Shroomer) {
            //Tektonra mehet, ahova a spórát szórjuk, vagy fonalat növesztünk oda. Egyelőre ideiglenes elágazás, és a gombafonalas cuccok is csak így láthatatlanban első gondolatra így kellene
            selectTecton(mouseX, mouseY);
            if(clickedTecton != null){
                if(keyHandler.getKeyCode() == KeyHandler.KEY_SPREAD_SPORE){ //S = spread spores
                    Spore sp = clickedMushroomBody.spreadSpores(clickedTecton, "spore", "random");
                    if(sp != null){
                        gc.getPlanet().getSpores().add(sp);
                        System.out.println("Spore added");
                        GeometryTecton tectonGeometry = clickedTecton.getGeometry();
                        sp.setGeometry(gc.randomOffsetInsideCircle(tectonGeometry));
                        gc.nextTurnCheck();
                    }
                }
                else if(keyHandler.getKeyCode() == KeyHandler.KEY_GROW_BODY) {
                    MushroomBody mb = clickedMushroomBody.giveBirth(gc.getPlanet().getSpores(), clickedTecton, gc.getPlanet().getMushbodies(), gc.getPlanet().getMushstrings(),(Shroomer) gc.getCurrentPlayer());
                    if(mb != null){
                        gc.getPlanet().getMushbodies().add(mb);
                        System.out.println("MushroomBody added");
                        GeometryTecton tectonGeometry = clickedTecton.getGeometry();
                        mb.setGeometry(gc.randomOffsetInsideCircle(tectonGeometry));
                        gc.nextTurnCheck();
                    }
                }
                else if(clickedTecton.canGrowHypha(gc.getPlanet().getMushstrings())){
                    if(clickedMushroomString != null){
                        if(clickedMushroomString.branch(clickedTecton, gc.getPlanet().getMushstrings()))
                            gc.nextTurnCheck();
                    }
                    else if(clickedMushroomBody != null && keyHandler.getKeyCode() == KeyHandler.KEY_HYPHA){ // H = hypha
                            if(clickedMushroomBody.getLocation().equals(clickedTecton)){
                                ArrayList<Tecton> connection = new ArrayList<>();
                                connection.add(clickedTecton);
                                connection.add(null);
                                GeometryString geom = new GeometryString(clickedMushroomBody.getGeometry().getX(), clickedMushroomBody.getGeometry().getY(), clickedTecton.getGeometry().getX(), clickedTecton.getGeometry().getY());
                                gc.getPlanet().getMushstrings().add(new MushroomString("hypha", ((Shroomer) gc.getCurrentPlayer()).getMushroom(), connection, new ArrayList<>(Arrays.asList(null, null)), gc.getTurnCounter(), geom));
                                gc.nextTurnCheck();
                            }
                    }
                }
            }
            reset();
        }
        else if(p instanceof Insecter) {
            //A kattintás egy tektonra, spórára, vagy fonalra mehet, de lehet itt is célszerű lenne gombokkal szabályozni, hogy ne lehessen véletlenül mondjuk félrekattintani, emiatt az if-ek ideiglenesek
            if(keyHandler.getKeyCode() == KeyHandler.KEY_MOVE){ // M = move
                selectTecton(mouseX, mouseY);
            }
            else if(keyHandler.getKeyCode() == KeyHandler.KEY_EAT){ //E = eat spore
                selectSpore(mouseX, mouseY);
            }
            else if(keyHandler.getKeyCode() == KeyHandler.KEY_CUT) { //C = cut
                selectMushroomString(mouseX, mouseY);
            }

            if(clickedTecton != null && clickedInsect.getLocation() != clickedTecton && clickedTecton.isNeighbour(clickedInsect.getLocation()) && gc.getPlanet().getMushstrings().stream()
                    .anyMatch(ms -> ms.getConnection().contains(clickedInsect.getLocation()) && ms.getConnection().contains(clickedTecton))) {
                clickedInsect.move(clickedTecton);
                gc.nextTurnCheck();
            }
            else if(clickedSpore != null) {
                if (clickedInsect.getLocation() == clickedSpore.getLocation()) {
                    SporeConsumptionVisitor v = new SporeConsumptionVisitor(clickedInsect, gc);
                    ((SporeAccept) clickedSpore).accept(v);
                    gc.nextTurnCheck();
                }
            }
            else if(clickedMushroomString != null) {
                clickedInsect.cutHypha(clickedMushroomString, gc.getPlanet().getMushstrings());
                gc.nextTurnCheck();
            }
          reset();
        }
    }

    /**
     * Az éles játék kattintásának feldolgozása aszerint, hogy ez a játékos "első kattintása" a legutóbbi akció óta, vagy sem
     * @param p A játékos, aki végzi a kattintást
     * @param mouseX a kattintás x koordinátája
     * @param mouseY a kattintás y koordinátája
     */
    private void gameClick(Player p, int mouseX, int mouseY) {
        if (firstClick) {
            firstGameClick(p, mouseX, mouseY);
        } else {
            secondGameClick(p, mouseX, mouseY);
        }
    }

    /**
     * A kattintás logikájáért felelős metódus, ami aszerint bontja ketté a feladatokat, hogy a játék inicializációs fázisban van-e, vagy sem
     * @param e A kattintás eseménye
     */
    @Override
    public void mouseClicked(MouseEvent e) {
        Player p = gc.getCurrentPlayer();
        int x = e.getX();
        int y = e.getY();
        if (gc.getInit()) {
            initClick(p, x, y);
        } else {
            gameClick(p, x, y);
        }
        repaintCallback.run();
    }

    @Override
    public void mousePressed(MouseEvent e) {}

    @Override
    public void mouseReleased(MouseEvent e) {}

    @Override
    public void mouseEntered(MouseEvent e) {
        // Ha a játék inicializáló fázisban van
        Player p = gc.getCurrentPlayer();
        if (gc.getInit()) {
            if (p instanceof Shroomer) {
                gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
            } else if (p instanceof Insecter) {
                gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
            }
        } else {
            // Normál játékmenet esetén
            int key = keyHandler.getKeyCode();

            if (p instanceof Shroomer) {
                if (firstClick) {
                    // Első kattintás esetén a megfelelő kiemelés beállítása a billentyű alapján
                    if (key == KeyHandler.KEY_GROW_BODY) {
                        gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
                    } else if (key == KeyHandler.KEY_MUSHROOM) {
                        gamePanel.setShineOn(GamePanel.ShineOn.MUSHBODY);
                    } else if (key == KeyHandler.KEY_BRANCH) {
                        gamePanel.setShineOn(GamePanel.ShineOn.MUSHSTRING);
                    }
                } else {
                    // Második kattintás esetén
                    if (clickedMushroomBody != null && key == KeyHandler.KEY_SPREAD_SPORE) {
                        gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
                    } else if (clickedMushroomString != null) {
                        gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
                    }
                }
            } else if (p instanceof Insecter) {
                if (firstClick) {
                    gamePanel.setShineOn(GamePanel.ShineOn.INSECT);
                } else {
                    // Második kattintás esetén az insecter akcióinak megfelelő kiemelés
                    if (key == KeyHandler.KEY_MOVE) {
                        gamePanel.setShineOn(GamePanel.ShineOn.TECTON);
                    } else if (key == KeyHandler.KEY_EAT) {
                        gamePanel.setShineOn(GamePanel.ShineOn.SPORE);
                    } else if (key == KeyHandler.KEY_CUT) {
                        gamePanel.setShineOn(GamePanel.ShineOn.MUSHSTRING);
                    }
                }
            }
        }
        repaintCallback.run();
    }


    @Override
    public void mouseExited(MouseEvent e) {}

}

================
File: src/main/java/MainMenu.java
================
package main.java;

import javax.swing.*;

import main.java.mushroom.Mushroom;
import main.java.player.Insecter;
import main.java.player.Player;
import main.java.player.Shroomer;
import main.java.view.UtilityTool;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class MainMenu extends JPanel {
	
	public static String prefix = "resources/";  //Intellij-ben írjátok be a resources/-t, eclipseben legyen üres sztring

    private final JFrame frame;
	
	public MainMenu(JFrame frame) {
		this.frame = frame;

		UtilityTool uTool = new UtilityTool();
		BufferedImage bgImage = uTool.load(prefix + "menu_bg6.png");

		ImageIcon backgroundIcon = new ImageIcon(bgImage);
		JLabel backgroundLabel = new JLabel(backgroundIcon);
		frame.setSize(bgImage.getWidth(), bgImage.getHeight());

		backgroundLabel.setLayout(new GridBagLayout());
		this.setLayout(new BorderLayout());
		this.add(backgroundLabel, BorderLayout.CENTER);

		Font buttonFont = new Font("SansSerif", Font.BOLD, 18);

        JButton newGameButton = new JButton("");
		BufferedImage b1Image = uTool.load(MainMenu.prefix + "bNewGame3.png");
		BufferedImage b1ImageHovered = uTool.load(MainMenu.prefix + "bNewGame3h.png");
		styleButton(newGameButton, buttonFont, b1Image, b1ImageHovered);

        JButton loadGameButton = new JButton("");
		BufferedImage b2Image = uTool.load(MainMenu.prefix + "bLoad3.png");
		BufferedImage b2ImageHovered = uTool.load(MainMenu.prefix + "bLoad3h.png");
		styleButton(loadGameButton, buttonFont, b2Image, b2ImageHovered);

        JButton exitButton = new JButton("");
		BufferedImage b3Image = uTool.load(MainMenu.prefix + "bExit3.png");
		BufferedImage b3ImageHovered = uTool.load(MainMenu.prefix + "bExit3h.png");
		styleButton(exitButton, buttonFont, b3Image, b3ImageHovered);

		newGameButton.addActionListener(e -> startGame());

		loadGameButton.addActionListener(e -> {
			if (GameFileChooser.loadGame(frame, frame)) {
				JOptionPane.showMessageDialog(frame, "Játékállapot sikeresen betöltve!", "Betöltés sikeres", JOptionPane.INFORMATION_MESSAGE);
				GameState state = null; //TODO
				startGameFromLoad(state);
			}
		});

		exitButton.addActionListener(e -> exit());

		GridBagConstraints c = new GridBagConstraints();
		c.insets = new Insets(25, 0, 25, 0);
		c.gridx = 0;

		c.gridy = 0;
		backgroundLabel.add(newGameButton, c);

		c.gridy = 1;
		backgroundLabel.add(loadGameButton, c);

		c.gridy = 2;
		backgroundLabel.add(exitButton, c);
	}

	/**
	 * A játékbeli gombok stílusát állítja be.
	 */
	private void styleButton(JButton button, Font font, BufferedImage image, BufferedImage hovered) {
		button.setFont(font);
		button.setFocusable(false);
        int BUTTON_WIDTH = 210;
        int BUTTON_HEIGHT = 95;
        button.setPreferredSize(new Dimension(BUTTON_WIDTH, BUTTON_HEIGHT));
		button.setContentAreaFilled(false);
		button.setBorderPainted(false);
		button.setOpaque(false);
		button.setForeground(Color.WHITE);

		Color baseColor = new Color(47, 84, 39);

		button.setBackground(baseColor);

		button.setIcon(new ImageIcon(image));
		button.setMargin(new Insets(0,20,0,0));

		button.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseEntered(java.awt.event.MouseEvent evt) {
				button.setIcon(new ImageIcon(hovered));
			}

			public void mouseExited(java.awt.event.MouseEvent evt) {
				button.setIcon(new ImageIcon(image));
			}
		});
	}

	/**
	 * A játékosok felvételéért felel.
	 */
	private ArrayList<Player> addPlayers()	{
		String insecterName1 = JOptionPane.showInputDialog(frame, "Enter name for Insecter 1:");
		String insecterName2 = JOptionPane.showInputDialog(frame, "Enter name for Insecter 2:");
		String shroomerName1 = JOptionPane.showInputDialog(frame, "Enter name for Shroomer 1:");
		String shroomerName2 = JOptionPane.showInputDialog(frame, "Enter name for Shroomer 2:");

		if (insecterName1 == null || insecterName2 == null || shroomerName1 == null || shroomerName2 == null ||
				insecterName1.isBlank() || insecterName2.isBlank() || shroomerName1.isBlank() || shroomerName2.isBlank()) {
			JOptionPane.showMessageDialog(frame, "All names must be provided.", "Input Error", JOptionPane.ERROR_MESSAGE);
			return null;
		}

		ArrayList<Player> players = new ArrayList<>();
		players.add(new Insecter(insecterName1, false));
		players.add(new Insecter(insecterName2, false));
		players.add(new Shroomer(shroomerName1, false, new Mushroom( false)));
		players.add(new Shroomer(shroomerName2, false, new Mushroom( false)));
		return players;
	}

	GamePanel gamePanel;

	/**
	 * Az új játék elindításáért felel.
	 */
	private void startGame() {
		ArrayList<Player> players = addPlayers();
		if(players != null) {
           	gamePanel = new GamePanel(players);
        } else {
			return;
		}
		frame.dispose();
		frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
		frame.setVisible(true);
		frame.setLayout(new BorderLayout());
		frame.getContentPane().removeAll();
		frame.setJMenuBar(new GameMenu(frame, gamePanel.getGameController()));
		frame.add(gamePanel, BorderLayout.CENTER);
		frame.revalidate();
		frame.repaint();
		gamePanel.requestFocusInWindow();
	}

	private void startGameFromLoad(GameState state){
		frame.dispose();
		frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
		frame.setVisible(true);
		frame.setLayout(new BorderLayout());
		frame.getContentPane().removeAll();
		frame.setJMenuBar(new GameMenu(frame, gamePanel.getGameController()));
		frame.add(gamePanel, BorderLayout.CENTER);
		frame.revalidate();
		frame.repaint();
		gamePanel.requestFocusInWindow();
	}

	private void exit() {
		System.exit(0);
	}
}

================
File: src/main/java/GameController.java
================
package main.java;


import java.util.ArrayList;
import java.util.Random;

import main.java.player.*;
import main.java.tecton.*;
import main.java.view.DefaultSporeDrawer;

/**
 * A GameController osztály felel a játék menetért, körváltásért, 
 * és a győztesek meghatározásáért. Egy Planet példányhoz kapcsolódik.
 */
public class GameController {

    private Planet planet;
    private int turnCounter;
    private final int maxTurn;
    private final boolean testing;
    private final ArrayList<Player> players;
    private Player currentPlayer;
    private final Runnable repaintCallback;

    private boolean init = true;
    
    /**
     * Létrehoz egy GameController példányt a megadott maximális körszámmal, és egy tesztelési paraméterrel.
     *
     * @param maxTurn a játék maximális körszámát adja meg
     */
    public GameController(boolean testing, int maxTurn, Runnable repaintCallback) {
    	this.maxTurn = maxTurn;
        this.testing = testing;
        this.repaintCallback = repaintCallback;
        planet = new Planet();
        players = new ArrayList<>();
        turnCounter = 1;
    }

    /**
     * A kirajzoláskor egy vélwtlen eltolást hoz létre az adott tektonon, hogy ne minden objektum egymáson legyen.
     *
     * @param geometry a felhasznált GeometryTecton példány
     * @return az új geometry
     */
    public Geometry randomOffsetInsideCircle(GeometryTecton geometry) {
        Random rand = new Random();
        Geometry g;
        int x, y;
        do {
            x = rand.nextInt(2 * geometry.getRadius()) - geometry.getRadius();
            y = rand.nextInt(2 * geometry.getRadius()) - geometry.getRadius();
        } while (Math.sqrt((x * x + y * y)) > geometry.getRadius() - DefaultSporeDrawer.SIZE);
        g = new Geometry(geometry.getX() + x, geometry.getY() + y);
        return g;
    }

    public void setInit(boolean init) {
        this.init = init;
    }

    /**
     * Létrehozza a pályát - ez egyelőre placeholder, kell több tecton majd
     */
    public Planet buildPlanet() {
    	Planet planet = new Planet();
    	
    	BigTecton t1 = new BigTecton(3);
    	t1.setGeometry(new GeometryTecton(600, 200, 110));

    	SmallTecton t2 = new SmallTecton(3);
    	t2.setGeometry(new GeometryTecton(900, 400, 55));
    	
    	HealingTecton t3 = new HealingTecton(3);
    	t3.setGeometry(new GeometryTecton(250, 250, 85));
    	
    	CoarseTecton t4 = new CoarseTecton(3);
    	t4.setGeometry(new GeometryTecton(400, 400, 90));
    	
    	ToxicTecton t5 = new ToxicTecton(3);
    	t5.setGeometry(new GeometryTecton(600, 600, 95));

        //Mushroom m = new Mushroom(false);
        //MushroomString ms1 = new MushroomString("hypha", m, new ArrayList<>(), new ArrayList<>(), 0, new GeometryString(0, 0, 100, 100));
    	
    	planet.addTecton(t1);
    	planet.addTecton(t2);
    	planet.addTecton(t3);
    	planet.addTecton(t4);
    	planet.addTecton(t5);
        //planet.addMushroomString(ms1);
        planet.recalcNeighbours();
    	
    	return planet;
    }

    /**
     * Megvizsgálja, hogy minden játékos letette-e már a kezdő objektumát. Ha igen, akkor innentől kezdve éles a játék.
     */
    public void setInitCheck()
    {
        if(planet.getInsects().size() == 2 && planet.getMushbodies().size() == 2) {
            init = false;
        }
    }

    //getterek, setterek
    public int getTurnCounter() {
    	return turnCounter;
    }

    public Planet getPlanet() {
        return planet;
    }

    public void setTurnCounter(int turnCounter) {
        this.turnCounter = turnCounter;
    }

    public int getMaxTurn() {
    	return maxTurn;
    }
    
    public void setPlanet(Planet newPlanet) {
        this.planet = newPlanet;
    }
    
    public ArrayList<Player> getPlayers() {
    	return players;
    }

    public Player getCurrentPlayer() {
    	return currentPlayer;
    }

    public void setCurrentPlayer(Player player) {
        this.currentPlayer = player;
    }

    public void setCurrentPlayerToNextPlayer() {
        int index = players.indexOf(currentPlayer);
        index = (index + 1) % players.size();
        currentPlayer = players.get(index);
    }

    public boolean getInit() {
        return init;
    }
    
    /**
     * Ezzel a metódussal lehet játékosokat hozzáadni a listához. Ha ez az első eleme, beállítja kezdőjátékosnak.
     *
     * @param player A játékos, akit hozzá szeretnénk adni a listához
     */
    public void addPlayer(Player player) {
    	players.add(player);
    	if(players.size() == 1) {
    		currentPlayer = players.get(0);
    	}
    }
    
    /** Egy játék-kör zárása:
     *  – ha minden játékos kifogyott az akcióból VAGY passzolt, új kör indul
     *  – ekkor Planet.update() fut, visszatöltjük az akciókat, körszámláló nő
     */
    public ArrayList<Player> nextTurnCheck() {
        planet.checkForDeadShrooms();
        planet.deleteDeadObjects(turnCounter, players);
        planet.checkForBodyConnection();

        if (currentPlayer.getActions() > 0) {
            currentPlayer.takeAction();
        }

        if (currentPlayer.getActions() == 0) {
            if (turnCounter == maxTurn) {
                return determineWinners();
            }
            int currentIndex = players.indexOf(currentPlayer);
            int nextIndex = (currentIndex + 1) % players.size();
            currentPlayer = players.get(nextIndex);
            turnCounter++;
            currentPlayer.update(testing);
            planet.update(!testing);
            planet.deleteDeadObjects(turnCounter, players);
        }
        repaintCallback.run();
        return new ArrayList<>();
    }


    /**
     * Meghatározza a játék győzteseit egy GameOverVisitor segítségével.
     *
     * @return egy lista, amely tartalmazza a legjobb Shroomer és Insecter típusú játékosokat
     */
    public ArrayList<Player> determineWinners() {
        GameOverVisitor visitor = new GameOverVisitor();
        ArrayList<Player> winners = new ArrayList<>();
        for (Player player : players) {
            ((PlayerAccept) player).accept(visitor);
        }
        if(visitor.getBestShroomer() != null) {
            winners.add(visitor.getBestShroomer());
        }
        if(visitor.getBestInsecter() != null) {
            winners.add(visitor.getBestInsecter());
        }
        return winners;
    }
}

================
File: src/main/java/GamePanel.java
================
package main.java;

import main.java.control.*;
import main.java.player.*;
import main.java.view.DrawManager;
import main.java.view.UtilityTool;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class GamePanel extends JPanel {

	public enum ShineOn {TECTON, MUSHBODY, MUSHSTRING, SPORE, INSECT, NONE}
	private ShineOn shineOn = ShineOn.NONE;

	private GameController gameController;
	private final DrawManager drawManager;
	private final BufferedImage backgroundImage;

    public GamePanel(ArrayList<Player> players) {
		gameController = new GameController(false, 20, this::repaint);
		gameController.setPlanet(gameController.buildPlanet());
        for (Player player : players) {
            gameController.addPlayer(player);
        }
		drawManager = new DrawManager();
		setBackground(Color.BLACK);
		setDoubleBuffered(true);
		UtilityTool ut = new UtilityTool();
		backgroundImage = ut.load(MainMenu.prefix + "Background_icon3.png");
        KeyHandler keyHandler = new KeyHandler(gameController, this::repaint, this);
        MouseHandler mouseHandler = new MouseHandler(gameController, this::repaint, this, keyHandler);
		this.addMouseListener(mouseHandler);
		this.addKeyListener(keyHandler);
		this.setFocusable(true);
	}

	public void setGameController(GameController gameController) {
		this.gameController = gameController;
	}

	public GameController getGameController() {
		return gameController;
	}

	//Getter és setter a kiemelés állításához
	public void setShineOn(ShineOn shineOn) {
		this.shineOn = shineOn;
	}

	/**
	 * Draws the game status information including player scores and current game state
 	 * @param g2 The Graphics2D context to draw on
 	*/
	private void drawGameStatus(Graphics2D g2) {
		ArrayList<Player> players = gameController.getPlayers();
		Font regularFont = new Font("SansSerif", Font.BOLD, 14);
		g2.setFont(regularFont);
		g2.setColor(Color.WHITE);

		int padding = 10;
		int lineHeight = g2.getFontMetrics().getHeight();
		int startX = getWidth() - 150;
		int startY = padding + lineHeight;

		for (int i = 0; i < players.size(); i++) {
			Player p = players.get(i);
			String text = p.getName() + " - " + p.getScore();
			g2.drawString(text, startX, startY + i * lineHeight);
		}

		Font statusFont = new Font("SansSerif", Font.BOLD, 16);
		g2.setFont(statusFont);

		// Create a transparent background for better readability
		int statusHeight = lineHeight * 2 + padding * 2;
		int statusWidth = 250;
		int statusX = getWidth() - statusWidth - padding;
		int statusY = getHeight() - statusHeight - padding;

		// Draw status background
		g2.setColor(new Color(0, 0, 0, 180)); // Semi-transparent black
		g2.fillRoundRect(statusX, statusY, statusWidth, statusHeight, 10, 10);

		// Draw status text
		g2.setColor(Color.WHITE);
		Player currentPlayer = gameController.getCurrentPlayer();
		int remainingRounds = gameController.getMaxTurn() - gameController.getTurnCounter();
		String playerText = "Current Player: " + (currentPlayer != null ? currentPlayer.getName() : "None");
		String roundText = "Remaining Rounds: " + remainingRounds;

		// Draw the status text
		g2.drawString(playerText, statusX + padding, statusY + lineHeight);
		g2.drawString(roundText, statusX + padding, statusY + lineHeight * 2);

		// If you want to highlight the current player's turn with a color
		if (currentPlayer != null) {
			Color playerColor;
			if (currentPlayer instanceof Shroomer) {
				playerColor = new Color(243, 3, 3); // Red for Shroomer
			} else {
				playerColor = new Color(255, 215, 0);   // Yellow for Insecter
			}

			g2.setColor(playerColor);
			g2.fillRoundRect(statusX + 160, statusY + lineHeight - 12, 10, 10, 5, 5);

			// Add player's remaining actions
			g2.setColor(Color.WHITE);
			g2.setFont(new Font("SansSerif", Font.PLAIN, 14));
			String actionsText = "Actions left: " + currentPlayer.getActions();
			g2.drawString(actionsText, statusX + padding, statusY + lineHeight * 3);
			if(gameController.getTurnCounter() == gameController.getMaxTurn())
			{
				ArrayList<Player> winners = gameController.nextTurnCheck();
				if (!winners.isEmpty()) {
					gameEndsPopup(winners);
				}
			}
		}
	}

	private void gameEndsPopup(ArrayList<Player> winners) {
        String message = "The winners are: " +
                winners.get(0).getName() + " and " +
                winners.get(1).getName() + "!";

		JOptionPane.showMessageDialog(this, message, "Game Over", JOptionPane.INFORMATION_MESSAGE);

		JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);
		frame.setJMenuBar(null);
		frame.getContentPane().removeAll();
		MainMenu menu = new MainMenu(frame);
		menu.setBackground(new Color(6, 26, 14));
		frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
		frame.add(menu);
		frame.revalidate();
		frame.repaint();
	}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		Graphics2D g2 = (Graphics2D) g;
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		if (backgroundImage != null) {
			g2.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), this);
		}
		drawManager.drawPlanet(g2, gameController.getPlanet(), shineOn);
		drawGameStatus(g2);
	}
}



================================================================
End of Codebase
================================================================
